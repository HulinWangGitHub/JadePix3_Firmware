/******************************************************************************/
/* Verilog models generated by SiliconSmart 2013.06-SP2 (Production) build number: 4464. */
/* Siliconsmart Path: /apps/snps/SiliconSmart-2013.06-SP2/linux26_x86_64/bin/siliconsmart */
/* Host Name: vncs02fc, User Name: avipa, PID: 13252                          */
/* Directory: /libraries/tsl18/tower/tsl18fs120/workspaces/tsl18fs120_avipa/fs120_svt */
/*                                                                            */
/* File generated on Wed Sep 10 12:16:28 IDT 2014.                            */
/******************************************************************************/


`timescale 1ns/1ps



`celldefine
module ad01d0( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ad01d0_func ad01d0_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	ad01d0_func ad01d0_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ad01d1( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ad01d1_func ad01d1_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	ad01d1_func ad01d1_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ad01d2( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ad01d2_func ad01d2_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	ad01d2_func ad01d2_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ad01d4( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ad01d4_func ad01d4_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	ad01d4_func ad01d4_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module adiode( I );
input I;

   `ifdef FUNCTIONAL  //  functional //

	adiode_func adiode_behav_inst(.I(I));

   `else

	adiode_func adiode_inst(.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module adp1d0( CO, P, S, A, B, CI );
input A, B, CI;
output CO, P, S;

   `ifdef FUNCTIONAL  //  functional //

	adp1d0_func adp1d0_behav_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));

   `else

	adp1d0_func adp1d0_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module adp1d1( CO, P, S, A, B, CI );
input A, B, CI;
output CO, P, S;

   `ifdef FUNCTIONAL  //  functional //

	adp1d1_func adp1d1_behav_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));

   `else

	adp1d1_func adp1d1_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module adp1d2( CO, P, S, A, B, CI );
input A, B, CI;
output CO, P, S;

   `ifdef FUNCTIONAL  //  functional //

	adp1d2_func adp1d2_behav_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));

   `else

	adp1d2_func adp1d2_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module adp1d4( CO, P, S, A, B, CI );
input A, B, CI;
output CO, P, S;

   `ifdef FUNCTIONAL  //  functional //

	adp1d4_func adp1d4_behav_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));

   `else

	adp1d4_func adp1d4_inst(.CO(CO),.P(P),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge A --> (P:A)
	 (posedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge A --> (P:A)
	 (negedge A => (P:A)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b0)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc posedge B --> (P:B)
	 (posedge B => (P:B)) = (1.0,1.0);

	if(CI===1'b1)
	// comb arc negedge B --> (P:B)
	 (negedge B => (P:B)) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ah01d0( CO, S, A, B );
input A, B;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ah01d0_func ah01d0_behav_inst(.CO(CO),.S(S),.A(A),.B(B));

   `else

	ah01d0_func ah01d0_inst(.CO(CO),.S(S),.A(A),.B(B));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	ifnone
	// comb arc posedge A --> (S:A)
	 (posedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc negedge A --> (S:A)
	 (negedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc posedge B --> (S:B)
	 (posedge B => (S:B)) = (1.0,1.0);

	ifnone
	// comb arc negedge B --> (S:B)
	 (negedge B => (S:B)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ah01d1( CO, S, A, B );
input A, B;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ah01d1_func ah01d1_behav_inst(.CO(CO),.S(S),.A(A),.B(B));

   `else

	ah01d1_func ah01d1_inst(.CO(CO),.S(S),.A(A),.B(B));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	ifnone
	// comb arc posedge A --> (S:A)
	 (posedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc negedge A --> (S:A)
	 (negedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc posedge B --> (S:B)
	 (posedge B => (S:B)) = (1.0,1.0);

	ifnone
	// comb arc negedge B --> (S:B)
	 (negedge B => (S:B)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ah01d2( CO, S, A, B );
input A, B;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ah01d2_func ah01d2_behav_inst(.CO(CO),.S(S),.A(A),.B(B));

   `else

	ah01d2_func ah01d2_inst(.CO(CO),.S(S),.A(A),.B(B));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	ifnone
	// comb arc posedge A --> (S:A)
	 (posedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc negedge A --> (S:A)
	 (negedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc posedge B --> (S:B)
	 (posedge B => (S:B)) = (1.0,1.0);

	ifnone
	// comb arc negedge B --> (S:B)
	 (negedge B => (S:B)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ah01d4( CO, S, A, B );
input A, B;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	ah01d4_func ah01d4_behav_inst(.CO(CO),.S(S),.A(A),.B(B));

   `else

	ah01d4_func ah01d4_inst(.CO(CO),.S(S),.A(A),.B(B));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	ifnone
	// comb arc posedge A --> (S:A)
	 (posedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc negedge A --> (S:A)
	 (negedge A => (S:A)) = (1.0,1.0);

	ifnone
	// comb arc posedge B --> (S:B)
	 (posedge B => (S:B)) = (1.0,1.0);

	ifnone
	// comb arc negedge B --> (S:B)
	 (negedge B => (S:B)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an02d0( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an02d0_func an02d0_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an02d0_func an02d0_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an02d1( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an02d1_func an02d1_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an02d1_func an02d1_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an02d2( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an02d2_func an02d2_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an02d2_func an02d2_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an02d4( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an02d4_func an02d4_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an02d4_func an02d4_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an02d7( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an02d7_func an02d7_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an02d7_func an02d7_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an02da( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an02da_func an02da_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an02da_func an02da_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an03d0( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an03d0_func an03d0_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	an03d0_func an03d0_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an03d1( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an03d1_func an03d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	an03d1_func an03d1_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an03d2( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an03d2_func an03d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	an03d2_func an03d2_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an03d4( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an03d4_func an03d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	an03d4_func an03d4_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an03d7( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an03d7_func an03d7_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	an03d7_func an03d7_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an03da( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an03da_func an03da_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	an03da_func an03da_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an04d0( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an04d0_func an04d0_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	an04d0_func an04d0_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an04d1( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an04d1_func an04d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	an04d1_func an04d1_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an04d2( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an04d2_func an04d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	an04d2_func an04d2_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an04d4( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an04d4_func an04d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	an04d4_func an04d4_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an04d7( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an04d7_func an04d7_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	an04d7_func an04d7_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an04da( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an04da_func an04da_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	an04da_func an04da_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an12d1( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an12d1_func an12d1_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an12d1_func an12d1_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an12d2( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an12d2_func an12d2_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an12d2_func an12d2_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module an12d4( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	an12d4_func an12d4_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	an12d4_func an12d4_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi211d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi211d1_func aoi211d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoi211d1_func aoi211d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi211d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi211d2_func aoi211d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoi211d2_func aoi211d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi211d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi211d4_func aoi211d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoi211d4_func aoi211d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi21d1( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi21d1_func aoi21d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	aoi21d1_func aoi21d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi21d2( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi21d2_func aoi21d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	aoi21d2_func aoi21d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi21d4( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi21d4_func aoi21d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	aoi21d4_func aoi21d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi221d1( ZN, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi221d1_func aoi221d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aoi221d1_func aoi221d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi221d2( ZN, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi221d2_func aoi221d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aoi221d2_func aoi221d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi221d4( ZN, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi221d4_func aoi221d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aoi221d4_func aoi221d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi2222d1( ZN, A1, A2, B1, B2, C1, C2, D1, D2 );
input A1, A2, B1, B2, C1, C2, D1, D2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi2222d1_func aoi2222d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));

   `else

	aoi2222d1_func aoi2222d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc D1 --> ZN
	 (D1 => ZN) = (1.0,1.0);

	// comb arc D2 --> ZN
	 (D2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi2222d2( ZN, A1, A2, B1, B2, C1, C2, D1, D2 );
input A1, A2, B1, B2, C1, C2, D1, D2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi2222d2_func aoi2222d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));

   `else

	aoi2222d2_func aoi2222d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc D1 --> ZN
	 (D1 => ZN) = (1.0,1.0);

	// comb arc D2 --> ZN
	 (D2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi2222d4( ZN, A1, A2, B1, B2, C1, C2, D1, D2 );
input A1, A2, B1, B2, C1, C2, D1, D2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi2222d4_func aoi2222d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));

   `else

	aoi2222d4_func aoi2222d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc D1 --> ZN
	 (D1 => ZN) = (1.0,1.0);

	// comb arc D2 --> ZN
	 (D2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi222d1( ZN, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi222d1_func aoi222d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aoi222d1_func aoi222d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi222d2( ZN, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi222d2_func aoi222d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aoi222d2_func aoi222d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi222d4( ZN, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi222d4_func aoi222d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aoi222d4_func aoi222d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi22d1( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi22d1_func aoi22d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aoi22d1_func aoi22d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi22d2( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi22d2_func aoi22d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aoi22d2_func aoi22d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi22d4( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi22d4_func aoi22d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aoi22d4_func aoi22d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi311d1( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi311d1_func aoi311d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi311d1_func aoi311d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi311d2( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi311d2_func aoi311d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi311d2_func aoi311d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi311d4( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi311d4_func aoi311d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi311d4_func aoi311d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi31d1( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi31d1_func aoi31d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aoi31d1_func aoi31d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi31d2( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi31d2_func aoi31d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aoi31d2_func aoi31d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi31d4( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi31d4_func aoi31d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aoi31d4_func aoi31d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi321d1( ZN, A, B1, B2, C1, C2, C3 );
input A, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi321d1_func aoi321d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi321d1_func aoi321d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi321d2( ZN, A, B1, B2, C1, C2, C3 );
input A, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi321d2_func aoi321d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi321d2_func aoi321d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi321d4( ZN, A, B1, B2, C1, C2, C3 );
input A, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi321d4_func aoi321d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi321d4_func aoi321d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi322d1( ZN, A1, A2, B1, B2, C1, C2, C3 );
input A1, A2, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi322d1_func aoi322d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi322d1_func aoi322d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi322d2( ZN, A1, A2, B1, B2, C1, C2, C3 );
input A1, A2, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi322d2_func aoi322d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi322d2_func aoi322d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoi322d4( ZN, A1, A2, B1, B2, C1, C2, C3 );
input A1, A2, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoi322d4_func aoi322d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoi322d4_func aoi322d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim211d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim211d1_func aoim211d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoim211d1_func aoim211d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim211d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim211d2_func aoim211d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoim211d2_func aoim211d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim211d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim211d4_func aoim211d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoim211d4_func aoim211d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim21d1( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim21d1_func aoim21d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	aoim21d1_func aoim21d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim21d2( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim21d2_func aoim21d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	aoim21d2_func aoim21d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim21d4( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim21d4_func aoim21d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	aoim21d4_func aoim21d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim22d1( Z, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aoim22d1_func aoim22d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aoim22d1_func aoim22d1_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim22d2( Z, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aoim22d2_func aoim22d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aoim22d2_func aoim22d2_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim22d4( Z, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aoim22d4_func aoim22d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aoim22d4_func aoim22d4_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim2m11d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim2m11d1_func aoim2m11d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoim2m11d1_func aoim2m11d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim2m11d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim2m11d2_func aoim2m11d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoim2m11d2_func aoim2m11d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim2m11d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim2m11d4_func aoim2m11d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aoim2m11d4_func aoim2m11d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim311d1( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim311d1_func aoim311d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoim311d1_func aoim311d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim311d2( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim311d2_func aoim311d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoim311d2_func aoim311d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim311d4( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim311d4_func aoim311d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoim311d4_func aoim311d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim31d1( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim31d1_func aoim31d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aoim31d1_func aoim31d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim31d2( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim31d2_func aoim31d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aoim31d2_func aoim31d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim31d4( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim31d4_func aoim31d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aoim31d4_func aoim31d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim3m11d1( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim3m11d1_func aoim3m11d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoim3m11d1_func aoim3m11d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim3m11d2( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim3m11d2_func aoim3m11d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoim3m11d2_func aoim3m11d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aoim3m11d4( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aoim3m11d4_func aoim3m11d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aoim3m11d4_func aoim3m11d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aon211d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aon211d1_func aon211d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aon211d1_func aon211d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aon211d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aon211d2_func aon211d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aon211d2_func aon211d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aon211d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	aon211d4_func aon211d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aon211d4_func aon211d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor211d1( Z, A, B, C1, C2 );
input A, B, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor211d1_func aor211d1_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aor211d1_func aor211d1_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor211d2( Z, A, B, C1, C2 );
input A, B, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor211d2_func aor211d2_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aor211d2_func aor211d2_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor211d4( Z, A, B, C1, C2 );
input A, B, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor211d4_func aor211d4_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	aor211d4_func aor211d4_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor21d1( Z, A, B1, B2 );
input A, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor21d1_func aor21d1_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));

   `else

	aor21d1_func aor21d1_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor21d2( Z, A, B1, B2 );
input A, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor21d2_func aor21d2_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));

   `else

	aor21d2_func aor21d2_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor21d4( Z, A, B1, B2 );
input A, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor21d4_func aor21d4_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));

   `else

	aor21d4_func aor21d4_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor221d1( Z, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor221d1_func aor221d1_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aor221d1_func aor221d1_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor221d2( Z, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor221d2_func aor221d2_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aor221d2_func aor221d2_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor221d4( Z, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor221d4_func aor221d4_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aor221d4_func aor221d4_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor222d1( Z, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor222d1_func aor222d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aor222d1_func aor222d1_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor222d2( Z, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor222d2_func aor222d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aor222d2_func aor222d2_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor222d4( Z, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor222d4_func aor222d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	aor222d4_func aor222d4_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor22d1( Z, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor22d1_func aor22d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aor22d1_func aor22d1_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor22d2( Z, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor22d2_func aor22d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aor22d2_func aor22d2_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor22d4( Z, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor22d4_func aor22d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	aor22d4_func aor22d4_inst(.Z(Z),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor311d1( Z, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor311d1_func aor311d1_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aor311d1_func aor311d1_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// comb arc C3 --> Z
	 (C3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor311d2( Z, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor311d2_func aor311d2_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aor311d2_func aor311d2_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// comb arc C3 --> Z
	 (C3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor311d4( Z, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor311d4_func aor311d4_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	aor311d4_func aor311d4_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// comb arc C3 --> Z
	 (C3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor31d1( Z, A, B1, B2, B3 );
input A, B1, B2, B3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor31d1_func aor31d1_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aor31d1_func aor31d1_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc B3 --> Z
	 (B3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor31d2( Z, A, B1, B2, B3 );
input A, B1, B2, B3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor31d2_func aor31d2_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aor31d2_func aor31d2_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc B3 --> Z
	 (B3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module aor31d4( Z, A, B1, B2, B3 );
input A, B1, B2, B3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	aor31d4_func aor31d4_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	aor31d4_func aor31d4_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc B3 --> Z
	 (B3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bh01d1( I );
inout I;

 buf (weak0, weak1) MGM_BG_0( I, MGM_WB_0 );

 buf MGM_BG_1( MGM_WB_0, I );

endmodule
`endcelldefine

/*
`celldefine
module bh01d1( I );
inout I;

   `ifdef FUNCTIONAL  //  functional //

	bh01d1_func bh01d1_behav_inst(.I(I));

   `else

	bh01d1_func bh01d1_inst(.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine
*/

`celldefine
module bufbd1( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbd1_func bufbd1_behav_inst(.Z(Z),.I(I));

   `else

	bufbd1_func bufbd1_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bufbd2( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbd2_func bufbd2_behav_inst(.Z(Z),.I(I));

   `else

	bufbd2_func bufbd2_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bufbd3( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbd3_func bufbd3_behav_inst(.Z(Z),.I(I));

   `else

	bufbd3_func bufbd3_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bufbd4( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbd4_func bufbd4_behav_inst(.Z(Z),.I(I));

   `else

	bufbd4_func bufbd4_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bufbd7( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbd7_func bufbd7_behav_inst(.Z(Z),.I(I));

   `else

	bufbd7_func bufbd7_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bufbda( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbda_func bufbda_behav_inst(.Z(Z),.I(I));

   `else

	bufbda_func bufbda_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bufbdf( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbdf_func bufbdf_behav_inst(.Z(Z),.I(I));

   `else

	bufbdf_func bufbdf_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module bufbdk( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	bufbdk_func bufbdk_behav_inst(.Z(Z),.I(I));

   `else

	bufbdk_func bufbdk_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buffd1( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buffd1_func buffd1_behav_inst(.Z(Z),.I(I));

   `else

	buffd1_func buffd1_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buffd2( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buffd2_func buffd2_behav_inst(.Z(Z),.I(I));

   `else

	buffd2_func buffd2_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buffd3( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buffd3_func buffd3_behav_inst(.Z(Z),.I(I));

   `else

	buffd3_func buffd3_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buffd4( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buffd4_func buffd4_behav_inst(.Z(Z),.I(I));

   `else

	buffd4_func buffd4_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buffd7( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buffd7_func buffd7_behav_inst(.Z(Z),.I(I));

   `else

	buffd7_func buffd7_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buffda( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buffda_func buffda_behav_inst(.Z(Z),.I(I));

   `else

	buffda_func buffda_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buftd1( Z, EN, I );
input EN, I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buftd1_func buftd1_behav_inst(.Z(Z),.EN(EN),.I(I));

   `else

	buftd1_func buftd1_inst(.Z(Z),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> Z
	 (EN => Z) = (1.0,1.0);

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buftd2( Z, EN, I );
input EN, I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buftd2_func buftd2_behav_inst(.Z(Z),.EN(EN),.I(I));

   `else

	buftd2_func buftd2_inst(.Z(Z),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> Z
	 (EN => Z) = (1.0,1.0);

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buftd4( Z, EN, I );
input EN, I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buftd4_func buftd4_behav_inst(.Z(Z),.EN(EN),.I(I));

   `else

	buftd4_func buftd4_inst(.Z(Z),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> Z
	 (EN => Z) = (1.0,1.0);

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buftd7( Z, EN, I );
input EN, I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buftd7_func buftd7_behav_inst(.Z(Z),.EN(EN),.I(I));

   `else

	buftd7_func buftd7_inst(.Z(Z),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> Z
	 (EN => Z) = (1.0,1.0);

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module buftda( Z, EN, I );
input EN, I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	buftda_func buftda_behav_inst(.Z(Z),.EN(EN),.I(I));

   `else

	buftda_func buftda_inst(.Z(Z),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> Z
	 (EN => Z) = (1.0,1.0);

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module cg01d0( CO, A, B, CI );
input A, B, CI;
output CO;

   `ifdef FUNCTIONAL  //  functional //

	cg01d0_func cg01d0_behav_inst(.CO(CO),.A(A),.B(B),.CI(CI));

   `else

	cg01d0_func cg01d0_inst(.CO(CO),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module cg01d1( CO, A, B, CI );
input A, B, CI;
output CO;

   `ifdef FUNCTIONAL  //  functional //

	cg01d1_func cg01d1_behav_inst(.CO(CO),.A(A),.B(B),.CI(CI));

   `else

	cg01d1_func cg01d1_inst(.CO(CO),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module cg01d2( CO, A, B, CI );
input A, B, CI;
output CO;

   `ifdef FUNCTIONAL  //  functional //

	cg01d2_func cg01d2_behav_inst(.CO(CO),.A(A),.B(B),.CI(CI));

   `else

	cg01d2_func cg01d2_inst(.CO(CO),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module cg01d4( CO, A, B, CI );
input A, B, CI;
output CO;

   `ifdef FUNCTIONAL  //  functional //

	cg01d4_func cg01d4_behav_inst(.CO(CO),.A(A),.B(B),.CI(CI));

   `else

	cg01d4_func cg01d4_inst(.CO(CO),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module clk2d2( C, CN, CLK );
input CLK;
output C, CN;

   `ifdef FUNCTIONAL  //  functional //

	clk2d2_func clk2d2_behav_inst(.C(C),.CN(CN),.CLK(CLK));

   `else

	clk2d2_func clk2d2_inst(.C(C),.CN(CN),.CLK(CLK));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> C
	 (CLK => C) = (1.0,1.0);

	// comb arc CLK --> CN
	 (CLK => CN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module cload1( I );
input I;

   `ifdef FUNCTIONAL  //  functional //

	cload1_func cload1_behav_inst(.I(I));

   `else

	cload1_func cload1_inst(.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module decfq1( Q, CDN, CPN, D, ENN );
input CDN, CPN, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	decfq1_func decfq1_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	decfq1_func decfq1_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,posedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,negedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module decfq2( Q, CDN, CPN, D, ENN );
input CDN, CPN, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	decfq2_func decfq2_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	decfq2_func decfq2_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,posedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,negedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module decfq4( Q, CDN, CPN, D, ENN );
input CDN, CPN, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	decfq4_func decfq4_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	decfq4_func decfq4_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,posedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,negedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module decrq1( Q, CDN, CP, D, ENN );
input CDN, CP, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	decrq1_func decrq1_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	decrq1_func decrq1_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module decrq2( Q, CDN, CP, D, ENN );
input CDN, CP, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	decrq2_func decrq2_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	decrq2_func decrq2_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module decrq4( Q, CDN, CP, D, ENN );
input CDN, CP, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	decrq4_func decrq4_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	decrq4_func decrq4_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module denrq1( Q, CP, D, ENN );
input CP, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	denrq1_func denrq1_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	denrq1_func denrq1_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module denrq2( Q, CP, D, ENN );
input CP, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	denrq2_func denrq2_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	denrq2_func denrq2_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module denrq4( Q, CP, D, ENN );
input CP, D, ENN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	denrq4_func denrq4_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	denrq4_func denrq4_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module depfq1( Q, CPN, D, ENN, SDN );
input CPN, D, ENN, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	depfq1_func depfq1_behav_inst(.Q(Q),.CPN(CPN),.D(D),.ENN(ENN),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SDN_delay ;

	depfq1_func depfq1_inst(.Q(Q),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,posedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,negedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module depfq2( Q, CPN, D, ENN, SDN );
input CPN, D, ENN, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	depfq2_func depfq2_behav_inst(.Q(Q),.CPN(CPN),.D(D),.ENN(ENN),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SDN_delay ;

	depfq2_func depfq2_inst(.Q(Q),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,posedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,negedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module depfq4( Q, CPN, D, ENN, SDN );
input CPN, D, ENN, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	depfq4_func depfq4_behav_inst(.Q(Q),.CPN(CPN),.D(D),.ENN(ENN),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SDN_delay ;

	depfq4_func depfq4_inst(.Q(Q),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,posedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN,negedge ENN,1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module deprq1( Q, CP, D, ENN, SDN );
input CP, D, ENN, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	deprq1_func deprq1_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SDN_delay ;

	deprq1_func deprq1_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module deprq2( Q, CP, D, ENN, SDN );
input CP, D, ENN, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	deprq2_func deprq2_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SDN_delay ;

	deprq2_func deprq2_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module deprq4( Q, CP, D, ENN, SDN );
input CP, D, ENN, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	deprq4_func deprq4_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SDN_delay ;

	deprq4_func deprq4_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfbfb1( Q, QN, CDN, CPN, D, SDN );
input CDN, CPN, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfbfb1_func dfbfb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfbfb1_func dfbfb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfbfb2( Q, QN, CDN, CPN, D, SDN );
input CDN, CPN, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfbfb2_func dfbfb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfbfb2_func dfbfb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfbfb4( Q, QN, CDN, CPN, D, SDN );
input CDN, CPN, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfbfb4_func dfbfb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfbfb4_func dfbfb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfbrb1( Q, QN, CDN, CP, D, SDN );
input CDN, CP, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfbrb1_func dfbrb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfbrb1_func dfbrb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfbrb2( Q, QN, CDN, CP, D, SDN );
input CDN, CP, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfbrb2_func dfbrb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfbrb2_func dfbrb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfbrb4( Q, QN, CDN, CP, D, SDN );
input CDN, CP, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfbrb4_func dfbrb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfbrb4_func dfbrb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcfb1( Q, QN, CDN, CPN, D );
input CDN, CPN, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcfb1_func dfcfb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	dfcfb1_func dfcfb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcfb2( Q, QN, CDN, CPN, D );
input CDN, CPN, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcfb2_func dfcfb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	dfcfb2_func dfcfb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcfb4( Q, QN, CDN, CPN, D );
input CDN, CPN, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcfb4_func dfcfb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	dfcfb4_func dfcfb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcfq1( Q, CDN, CPN, D );
input CDN, CPN, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcfq1_func dfcfq1_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	dfcfq1_func dfcfq1_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcfq2( Q, CDN, CPN, D );
input CDN, CPN, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcfq2_func dfcfq2_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	dfcfq2_func dfcfq2_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcfq4( Q, CDN, CPN, D );
input CDN, CPN, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcfq4_func dfcfq4_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	dfcfq4_func dfcfq4_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrb1( Q, QN, CDN, CP, D );
input CDN, CP, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrb1_func dfcrb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrb1_func dfcrb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrb2( Q, QN, CDN, CP, D );
input CDN, CP, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrb2_func dfcrb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrb2_func dfcrb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrb4( Q, QN, CDN, CP, D );
input CDN, CP, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrb4_func dfcrb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrb4_func dfcrb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrn1( QN, CDN, CP, D );
input CDN, CP, D;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrn1_func dfcrn1_behav_inst(.QN(QN),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrn1_func dfcrn1_inst(.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrn2( QN, CDN, CP, D );
input CDN, CP, D;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrn2_func dfcrn2_behav_inst(.QN(QN),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrn2_func dfcrn2_inst(.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrn4( QN, CDN, CP, D );
input CDN, CP, D;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrn4_func dfcrn4_behav_inst(.QN(QN),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrn4_func dfcrn4_inst(.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrq1( Q, CDN, CP, D );
input CDN, CP, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrq1_func dfcrq1_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrq1_func dfcrq1_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrq2( Q, CDN, CP, D );
input CDN, CP, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrq2_func dfcrq2_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	dfcrq2_func dfcrq2_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfcrq4( CP, CDN, D, Q );
input CDN, CP, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfcrq4_func dfcrq4_behav_inst(.CP(CP),.CDN(CDN),.D(D),.Q(Q),.notifier(notifier));

   `else

	wire CP_delay ;

	wire CDN_delay ;

	wire D_delay ;

	dfcrq4_func dfcrq4_inst(.CP(CP_delay),.CDN(CDN_delay),.D(D_delay),.Q(Q),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnfb1( Q, QN, CPN, D );
input CPN, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnfb1_func dfnfb1_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	dfnfb1_func dfnfb1_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnfb2( Q, QN, CPN, D );
input CPN, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnfb2_func dfnfb2_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	dfnfb2_func dfnfb2_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnfb4( Q, QN, CPN, D );
input CPN, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnfb4_func dfnfb4_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	dfnfb4_func dfnfb4_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrb1( Q, QN, CP, D );
input CP, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrb1_func dfnrb1_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrb1_func dfnrb1_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrb2( Q, QN, CP, D );
input CP, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrb2_func dfnrb2_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrb2_func dfnrb2_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrb4( Q, QN, CP, D );
input CP, D;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrb4_func dfnrb4_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrb4_func dfnrb4_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrn1( QN, CP, D );
input CP, D;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrn1_func dfnrn1_behav_inst(.QN(QN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrn1_func dfnrn1_inst(.QN(QN),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrn2( QN, CP, D );
input CP, D;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrn2_func dfnrn2_behav_inst(.QN(QN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrn2_func dfnrn2_inst(.QN(QN),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrn4( QN, CP, D );
input CP, D;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrn4_func dfnrn4_behav_inst(.QN(QN),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrn4_func dfnrn4_inst(.QN(QN),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrq1( Q, CP, D );
input CP, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrq1_func dfnrq1_behav_inst(.Q(Q),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrq1_func dfnrq1_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrq2( Q, CP, D );
input CP, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrq2_func dfnrq2_behav_inst(.Q(Q),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrq2_func dfnrq2_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfnrq4( Q, CP, D );
input CP, D;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfnrq4_func dfnrq4_behav_inst(.Q(Q),.CP(CP),.D(D),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	dfnrq4_func dfnrq4_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfpfb1( Q, QN, CPN, D, SDN );
input CPN, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfpfb1_func dfpfb1_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfpfb1_func dfpfb1_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfpfb2( Q, QN, CPN, D, SDN );
input CPN, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfpfb2_func dfpfb2_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfpfb2_func dfpfb2_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfpfb4( Q, QN, CPN, D, SDN );
input CPN, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfpfb4_func dfpfb4_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfpfb4_func dfpfb4_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,posedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN,negedge D,1.0,1.0,notifier,,,CPN_delay,D_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfprb1( Q, QN, CP, D, SDN );
input CP, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfprb1_func dfprb1_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfprb1_func dfprb1_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfprb2( Q, QN, CP, D, SDN );
input CP, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfprb2_func dfprb2_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfprb2_func dfprb2_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dfprb4( Q, QN, CP, D, SDN );
input CP, D, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	dfprb4_func dfprb4_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SDN_delay ;

	dfprb4_func dfprb4_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl01d1( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl01d1_func dl01d1_behav_inst(.Z(Z),.I(I));

   `else

	dl01d1_func dl01d1_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl01d2( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl01d2_func dl01d2_behav_inst(.Z(Z),.I(I));

   `else

	dl01d2_func dl01d2_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl01d4( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl01d4_func dl01d4_behav_inst(.Z(Z),.I(I));

   `else

	dl01d4_func dl01d4_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl02d1( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl02d1_func dl02d1_behav_inst(.Z(Z),.I(I));

   `else

	dl02d1_func dl02d1_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl02d2( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl02d2_func dl02d2_behav_inst(.Z(Z),.I(I));

   `else

	dl02d2_func dl02d2_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl02d4( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl02d4_func dl02d4_behav_inst(.Z(Z),.I(I));

   `else

	dl02d4_func dl02d4_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl03d1( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl03d1_func dl03d1_behav_inst(.Z(Z),.I(I));

   `else

	dl03d1_func dl03d1_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl03d2( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl03d2_func dl03d2_behav_inst(.Z(Z),.I(I));

   `else

	dl03d2_func dl03d2_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl03d4( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl03d4_func dl03d4_behav_inst(.Z(Z),.I(I));

   `else

	dl03d4_func dl03d4_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl04d1( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl04d1_func dl04d1_behav_inst(.Z(Z),.I(I));

   `else

	dl04d1_func dl04d1_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl04d2( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl04d2_func dl04d2_behav_inst(.Z(Z),.I(I));

   `else

	dl04d2_func dl04d2_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module dl04d4( Z, I );
input I;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	dl04d4_func dl04d4_behav_inst(.Z(Z),.I(I));

   `else

	dl04d4_func dl04d4_inst(.Z(Z),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> Z
	 (I => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclfsn1( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclfsn1_func gclfsn1_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclfsn1_func gclfsn1_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_lh 
	$width(posedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclfsn2( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclfsn2_func gclfsn2_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclfsn2_func gclfsn2_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_lh 
	$width(posedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclfsn4( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclfsn4_func gclfsn4_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclfsn4_func gclfsn4_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_lh 
	$width(posedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclfsn7( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclfsn7_func gclfsn7_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclfsn7_func gclfsn7_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_lh 
	$width(posedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclfsna( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclfsna_func gclfsna_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclfsna_func gclfsna_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-HL
	$setuphold(negedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_lh 
	$width(posedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclrsn1( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclrsn1_func gclrsn1_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclrsn1_func gclrsn1_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclrsn2( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclrsn2_func gclrsn2_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclrsn2_func gclrsn2_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclrsn4( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclrsn4_func gclrsn4_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclrsn4_func gclrsn4_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclrsn7( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclrsn7_func gclrsn7_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclrsn7_func gclrsn7_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gclrsna( GCLK, CLK, EN, SE );
input CLK, EN, SE;
output GCLK;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	gclrsna_func gclrsna_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN),.SE(SE),.notifier(notifier));

   `else

	wire CLK_delay ;

	wire EN_delay ;

	gclrsna_func gclrsna_inst(.GCLK(GCLK),.CLK(CLK_delay),.EN(EN_delay),.SE(SE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc SE --> GCLK
	 (SE => GCLK) = (1.0,1.0);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,posedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// setuphold EN- CLK-LH
	$setuphold(posedge CLK,negedge EN,1.0,1.0,notifier,,,CLK_delay,EN_delay);

	// mpw CLK_hl 
	$width(negedge CLK,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnfnn1( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnfnn1_func gcnfnn1_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnfnn1_func gcnfnn1_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-LH
	$nochange(posedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-LH
	$nochange(posedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnfnn2( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnfnn2_func gcnfnn2_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnfnn2_func gcnfnn2_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-LH
	$nochange(posedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-LH
	$nochange(posedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnfnn4( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnfnn4_func gcnfnn4_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnfnn4_func gcnfnn4_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-LH
	$nochange(posedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-LH
	$nochange(posedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnfnn7( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnfnn7_func gcnfnn7_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnfnn7_func gcnfnn7_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-LH
	$nochange(posedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-LH
	$nochange(posedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnfnna( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnfnna_func gcnfnna_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnfnna_func gcnfnna_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-LH
	$nochange(posedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-LH
	$nochange(posedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnrnn1( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnrnn1_func gcnrnn1_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnrnn1_func gcnrnn1_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-HL
	$nochange(negedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-HL
	$nochange(negedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnrnn2( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnrnn2_func gcnrnn2_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnrnn2_func gcnrnn2_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-HL
	$nochange(negedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-HL
	$nochange(negedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnrnn4( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnrnn4_func gcnrnn4_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnrnn4_func gcnrnn4_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-HL
	$nochange(negedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-HL
	$nochange(negedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnrnn7( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnrnn7_func gcnrnn7_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnrnn7_func gcnrnn7_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-HL
	$nochange(negedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-HL
	$nochange(negedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module gcnrnna( GCLK, CLK, EN );
input CLK, EN;
output GCLK;

   `ifdef FUNCTIONAL  //  functional //

	gcnrnna_func gcnrnna_behav_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));

   `else

	gcnrnna_func gcnrnna_inst(.GCLK(GCLK),.CLK(CLK),.EN(EN));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc CLK --> GCLK
	 (CLK => GCLK) = (1.0,1.0);

	// comb arc EN --> GCLK
	 (EN => GCLK) = (1.0,1.0);

	// nochangeEN-LH CLK-HL
	$nochange(negedge CLK,posedge EN,1.0,1.0);

	// nochangeEN-HL CLK-HL
	$nochange(negedge CLK,negedge EN,1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module inv0d0( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	inv0d0_func inv0d0_behav_inst(.ZN(ZN),.I(I));

   `else

	inv0d0_func inv0d0_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module inv0d1( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	inv0d1_func inv0d1_behav_inst(.ZN(ZN),.I(I));

   `else

	inv0d1_func inv0d1_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module inv0d2( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	inv0d2_func inv0d2_behav_inst(.ZN(ZN),.I(I));

   `else

	inv0d2_func inv0d2_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module inv0d4( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	inv0d4_func inv0d4_behav_inst(.ZN(ZN),.I(I));

   `else

	inv0d4_func inv0d4_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module inv0d7( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	inv0d7_func inv0d7_behav_inst(.ZN(ZN),.I(I));

   `else

	inv0d7_func inv0d7_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module inv0da( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	inv0da_func inv0da_behav_inst(.ZN(ZN),.I(I));

   `else

	inv0da_func inv0da_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invbd2( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invbd2_func invbd2_behav_inst(.ZN(ZN),.I(I));

   `else

	invbd2_func invbd2_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invbd4( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invbd4_func invbd4_behav_inst(.ZN(ZN),.I(I));

   `else

	invbd4_func invbd4_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invbd7( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invbd7_func invbd7_behav_inst(.ZN(ZN),.I(I));

   `else

	invbd7_func invbd7_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invbda( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invbda_func invbda_behav_inst(.ZN(ZN),.I(I));

   `else

	invbda_func invbda_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invbdf( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invbdf_func invbdf_behav_inst(.ZN(ZN),.I(I));

   `else

	invbdf_func invbdf_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invbdk( ZN, I );
input I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invbdk_func invbdk_behav_inst(.ZN(ZN),.I(I));

   `else

	invbdk_func invbdk_inst(.ZN(ZN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invtd1( ZN, EN, I );
input EN, I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invtd1_func invtd1_behav_inst(.ZN(ZN),.EN(EN),.I(I));

   `else

	invtd1_func invtd1_inst(.ZN(ZN),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> ZN
	 (EN => ZN) = (1.0,1.0);

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invtd2( ZN, EN, I );
input EN, I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invtd2_func invtd2_behav_inst(.ZN(ZN),.EN(EN),.I(I));

   `else

	invtd2_func invtd2_inst(.ZN(ZN),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> ZN
	 (EN => ZN) = (1.0,1.0);

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invtd4( ZN, EN, I );
input EN, I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invtd4_func invtd4_behav_inst(.ZN(ZN),.EN(EN),.I(I));

   `else

	invtd4_func invtd4_inst(.ZN(ZN),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> ZN
	 (EN => ZN) = (1.0,1.0);

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invtd7( ZN, EN, I );
input EN, I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invtd7_func invtd7_behav_inst(.ZN(ZN),.EN(EN),.I(I));

   `else

	invtd7_func invtd7_inst(.ZN(ZN),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> ZN
	 (EN => ZN) = (1.0,1.0);

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module invtda( ZN, EN, I );
input EN, I;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	invtda_func invtda_behav_inst(.ZN(ZN),.EN(EN),.I(I));

   `else

	invtda_func invtda_inst(.ZN(ZN),.EN(EN),.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc EN --> ZN
	 (EN => ZN) = (1.0,1.0);

	// comb arc I --> ZN
	 (I => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module jkbrb1( Q, QN, CDN, CP, J, KZ, SDN );
input CDN, CP, J, KZ, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	jkbrb1_func jkbrb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.J(J),.KZ(KZ),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire J_delay ;

	wire KZ_delay ;

	wire SDN_delay ;

	jkbrb1_func jkbrb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.J(J_delay),.KZ(KZ_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : J))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : J))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP,posedge J,1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP,negedge J,1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP,posedge KZ,1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP,negedge KZ,1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module jkbrb2( Q, QN, CDN, CP, J, KZ, SDN );
input CDN, CP, J, KZ, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	jkbrb2_func jkbrb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.J(J),.KZ(KZ),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire J_delay ;

	wire KZ_delay ;

	wire SDN_delay ;

	jkbrb2_func jkbrb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.J(J_delay),.KZ(KZ_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : J))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : J))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP,posedge J,1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP,negedge J,1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP,posedge KZ,1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP,negedge KZ,1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module jkbrb4( Q, QN, CDN, CP, J, KZ, SDN );
input CDN, CP, J, KZ, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	jkbrb4_func jkbrb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.J(J),.KZ(KZ),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire J_delay ;

	wire KZ_delay ;

	wire SDN_delay ;

	jkbrb4_func jkbrb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.J(J_delay),.KZ(KZ_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : J))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : J))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP,posedge J,1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP,negedge J,1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP,posedge KZ,1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP,negedge KZ,1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module labhb1( Q, QN, CDN, D, E, SDN );
input CDN, D, E, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	labhb1_func labhb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.D(D),.E(E),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SDN_delay ;

	labhb1_func labhb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// recrem SDN-E-negedge
	$recrem(posedge SDN,negedge E,1.0,1.0,notifier,,,SDN_delay,E_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module labhb2( Q, QN, CDN, D, E, SDN );
input CDN, D, E, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	labhb2_func labhb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.D(D),.E(E),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SDN_delay ;

	labhb2_func labhb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// recrem SDN-E-negedge
	$recrem(posedge SDN,negedge E,1.0,1.0,notifier,,,SDN_delay,E_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module labhb4( Q, QN, CDN, D, E, SDN );
input CDN, D, E, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	labhb4_func labhb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.D(D),.E(E),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SDN_delay ;

	labhb4_func labhb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// recrem SDN-E-negedge
	$recrem(posedge SDN,negedge E,1.0,1.0,notifier,,,SDN_delay,E_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lachq1( Q, CDN, D, E );
input CDN, D, E;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lachq1_func lachq1_behav_inst(.Q(Q),.CDN(CDN),.D(D),.E(E),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	lachq1_func lachq1_inst(.Q(Q),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lachq2( Q, CDN, D, E );
input CDN, D, E;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lachq2_func lachq2_behav_inst(.Q(Q),.CDN(CDN),.D(D),.E(E),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	lachq2_func lachq2_inst(.Q(Q),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lachq4( Q, CDN, D, E );
input CDN, D, E;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lachq4_func lachq4_behav_inst(.Q(Q),.CDN(CDN),.D(D),.E(E),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	lachq4_func lachq4_inst(.Q(Q),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module laclq1( Q, CDN, D, EN );
input CDN, D, EN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	laclq1_func laclq1_behav_inst(.Q(Q),.CDN(CDN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire EN_delay ;

	laclq1_func laclq1_inst(.Q(Q),.CDN(CDN_delay),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// recrem CDN-EN-posedge
	$recrem(posedge CDN,posedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module laclq2( Q, CDN, D, EN );
input CDN, D, EN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	laclq2_func laclq2_behav_inst(.Q(Q),.CDN(CDN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire EN_delay ;

	laclq2_func laclq2_inst(.Q(Q),.CDN(CDN_delay),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// recrem CDN-EN-posedge
	$recrem(posedge CDN,posedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module laclq4( Q, CDN, D, EN );
input CDN, D, EN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	laclq4_func laclq4_behav_inst(.Q(Q),.CDN(CDN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire EN_delay ;

	laclq4_func laclq4_inst(.Q(Q),.CDN(CDN_delay),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// recrem CDN-EN-posedge
	$recrem(posedge CDN,posedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhb1( Q, QN, D, E );
input D, E;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhb1_func lanhb1_behav_inst(.Q(Q),.QN(QN),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhb1_func lanhb1_inst(.Q(Q),.QN(QN),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhb2( Q, QN, D, E );
input D, E;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhb2_func lanhb2_behav_inst(.Q(Q),.QN(QN),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhb2_func lanhb2_inst(.Q(Q),.QN(QN),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhb4( Q, QN, D, E );
input D, E;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhb4_func lanhb4_behav_inst(.Q(Q),.QN(QN),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhb4_func lanhb4_inst(.Q(Q),.QN(QN),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhn1( QN, D, E );
input D, E;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhn1_func lanhn1_behav_inst(.QN(QN),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhn1_func lanhn1_inst(.QN(QN),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhn2( QN, D, E );
input D, E;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhn2_func lanhn2_behav_inst(.QN(QN),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhn2_func lanhn2_inst(.QN(QN),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhn4( QN, D, E );
input D, E;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhn4_func lanhn4_behav_inst(.QN(QN),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhn4_func lanhn4_inst(.QN(QN),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhq1( Q, D, E );
input D, E;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhq1_func lanhq1_behav_inst(.Q(Q),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhq1_func lanhq1_inst(.Q(Q),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhq2( Q, D, E );
input D, E;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhq2_func lanhq2_behav_inst(.Q(Q),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhq2_func lanhq2_inst(.Q(Q),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanhq4( Q, D, E );
input D, E;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanhq4_func lanhq4_behav_inst(.Q(Q),.D(D),.E(E),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanhq4_func lanhq4_inst(.Q(Q),.D(D_delay),.E(E_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanht1( Z, D, E, OE );
input D, E, OE;
output Z;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanht1_func lanht1_behav_inst(.Z(Z),.D(D),.E(E),.OE(OE),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanht1_func lanht1_inst(.Z(Z),.D(D_delay),.E(E_delay),.OE(OE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Z
	 (D => Z) = (1.0,1.0);

	// seq arc E --> Z
	(posedge E => (Z : D))  = (1.0,1.0);

	// comb arc OE --> Z
	 (OE => Z) = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanht2( Z, D, E, OE );
input D, E, OE;
output Z;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanht2_func lanht2_behav_inst(.Z(Z),.D(D),.E(E),.OE(OE),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanht2_func lanht2_inst(.Z(Z),.D(D_delay),.E(E_delay),.OE(OE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Z
	 (D => Z) = (1.0,1.0);

	// seq arc E --> Z
	(posedge E => (Z : D))  = (1.0,1.0);

	// comb arc OE --> Z
	 (OE => Z) = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanht4( Z, D, E, OE );
input D, E, OE;
output Z;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanht4_func lanht4_behav_inst(.Z(Z),.D(D),.E(E),.OE(OE),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	lanht4_func lanht4_inst(.Z(Z),.D(D_delay),.E(E_delay),.OE(OE),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Z
	 (D => Z) = (1.0,1.0);

	// seq arc E --> Z
	(posedge E => (Z : D))  = (1.0,1.0);

	// comb arc OE --> Z
	 (OE => Z) = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E,posedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E,negedge D,1.0,1.0,notifier,,,E_delay,D_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanlb1( Q, QN, D, EN );
input D, EN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanlb1_func lanlb1_behav_inst(.Q(Q),.QN(QN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanlb1_func lanlb1_inst(.Q(Q),.QN(QN),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanlb2( Q, QN, D, EN );
input D, EN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanlb2_func lanlb2_behav_inst(.Q(Q),.QN(QN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanlb2_func lanlb2_inst(.Q(Q),.QN(QN),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanlb4( Q, QN, D, EN );
input D, EN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanlb4_func lanlb4_behav_inst(.Q(Q),.QN(QN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanlb4_func lanlb4_inst(.Q(Q),.QN(QN),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanln1( QN, D, EN );
input D, EN;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanln1_func lanln1_behav_inst(.QN(QN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanln1_func lanln1_inst(.QN(QN),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanln2( QN, D, EN );
input D, EN;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanln2_func lanln2_behav_inst(.QN(QN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanln2_func lanln2_inst(.QN(QN),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanln4( QN, D, EN );
input D, EN;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanln4_func lanln4_behav_inst(.QN(QN),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanln4_func lanln4_inst(.QN(QN),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanlq1( Q, D, EN );
input D, EN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanlq1_func lanlq1_behav_inst(.Q(Q),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanlq1_func lanlq1_inst(.Q(Q),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanlq2( Q, D, EN );
input D, EN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanlq2_func lanlq2_behav_inst(.Q(Q),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanlq2_func lanlq2_inst(.Q(Q),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module lanlq4( Q, D, EN );
input D, EN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	lanlq4_func lanlq4_behav_inst(.Q(Q),.D(D),.EN(EN),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	lanlq4_func lanlq4_inst(.Q(Q),.D(D_delay),.EN(EN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN,posedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN,negedge D,1.0,1.0,notifier,,,EN_delay,D_delay);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mffnrb1( Q, QN, CP, D, ENN );
input CP, D, ENN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	mffnrb1_func mffnrb1_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	mffnrb1_func mffnrb1_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mffnrb2( Q, QN, CP, D, ENN );
input CP, D, ENN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	mffnrb2_func mffnrb2_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	mffnrb2_func mffnrb2_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mffnrb4( Q, QN, CP, D, ENN );
input CP, D, ENN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	mffnrb4_func mffnrb4_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.ENN(ENN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	mffnrb4_func mffnrb4_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP,posedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP,negedge D,1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,posedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP,negedge ENN,1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mi02d0( S, ZN, I0, I1 );
input I0, I1, S;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	mi02d0_func mi02d0_behav_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));

   `else

	mi02d0_func mi02d0_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> ZN
	 (I0 => ZN) = (1.0,1.0);

	// comb arc I1 --> ZN
	 (I1 => ZN) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (ZN:S)
	 (posedge S => (ZN:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (ZN:S)
	 (negedge S => (ZN:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mi02d1( S, ZN, I0, I1 );
input I0, I1, S;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	mi02d1_func mi02d1_behav_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));

   `else

	mi02d1_func mi02d1_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> ZN
	 (I0 => ZN) = (1.0,1.0);

	// comb arc I1 --> ZN
	 (I1 => ZN) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (ZN:S)
	 (posedge S => (ZN:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (ZN:S)
	 (negedge S => (ZN:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mi02d2( S, ZN, I0, I1 );
input I0, I1, S;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	mi02d2_func mi02d2_behav_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));

   `else

	mi02d2_func mi02d2_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> ZN
	 (I0 => ZN) = (1.0,1.0);

	// comb arc I1 --> ZN
	 (I1 => ZN) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (ZN:S)
	 (posedge S => (ZN:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (ZN:S)
	 (negedge S => (ZN:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mi02d4( S, ZN, I0, I1 );
input I0, I1, S;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	mi02d4_func mi02d4_behav_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));

   `else

	mi02d4_func mi02d4_inst(.S(S),.ZN(ZN),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> ZN
	 (I0 => ZN) = (1.0,1.0);

	// comb arc I1 --> ZN
	 (I1 => ZN) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (ZN:S)
	 (posedge S => (ZN:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (ZN:S)
	 (negedge S => (ZN:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx02d0( S, Z, I0, I1 );
input I0, I1, S;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx02d0_func mx02d0_behav_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));

   `else

	mx02d0_func mx02d0_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (Z:S)
	 (posedge S => (Z:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (Z:S)
	 (negedge S => (Z:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx02d1( S, Z, I0, I1 );
input I0, I1, S;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx02d1_func mx02d1_behav_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));

   `else

	mx02d1_func mx02d1_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (Z:S)
	 (posedge S => (Z:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (Z:S)
	 (negedge S => (Z:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx02d2( S, Z, I0, I1 );
input I0, I1, S;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx02d2_func mx02d2_behav_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));

   `else

	mx02d2_func mx02d2_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (Z:S)
	 (posedge S => (Z:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (Z:S)
	 (negedge S => (Z:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx02d4( S, Z, I0, I1 );
input I0, I1, S;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx02d4_func mx02d4_behav_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));

   `else

	mx02d4_func mx02d4_inst(.S(S),.Z(Z),.I0(I0),.I1(I1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	ifnone
	// comb arc posedge S --> (Z:S)
	 (posedge S => (Z:S)) = (1.0,1.0);

	ifnone
	// comb arc negedge S --> (Z:S)
	 (negedge S => (Z:S)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx04d0( Z, I0, I1, I2, I3, S0, S1 );
input I0, I1, I2, I3, S0, S1;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx04d0_func mx04d0_behav_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));

   `else

	mx04d0_func mx04d0_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	// comb arc I2 --> Z
	 (I2 => Z) = (1.0,1.0);

	// comb arc I3 --> Z
	 (I3 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx04d1( Z, I0, I1, I2, I3, S0, S1 );
input I0, I1, I2, I3, S0, S1;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx04d1_func mx04d1_behav_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));

   `else

	mx04d1_func mx04d1_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	// comb arc I2 --> Z
	 (I2 => Z) = (1.0,1.0);

	// comb arc I3 --> Z
	 (I3 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx04d2( Z, I0, I1, I2, I3, S0, S1 );
input I0, I1, I2, I3, S0, S1;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx04d2_func mx04d2_behav_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));

   `else

	mx04d2_func mx04d2_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	// comb arc I2 --> Z
	 (I2 => Z) = (1.0,1.0);

	// comb arc I3 --> Z
	 (I3 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module mx04d4( Z, I0, I1, I2, I3, S0, S1 );
input I0, I1, I2, I3, S0, S1;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	mx04d4_func mx04d4_behav_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));

   `else

	mx04d4_func mx04d4_inst(.Z(Z),.I0(I0),.I1(I1),.I2(I2),.I3(I3),.S0(S0),.S1(S1));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc I0 --> Z
	 (I0 => Z) = (1.0,1.0);

	// comb arc I1 --> Z
	 (I1 => Z) = (1.0,1.0);

	// comb arc I2 --> Z
	 (I2 => Z) = (1.0,1.0);

	// comb arc I3 --> Z
	 (I3 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S1===1'b0)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S1===1'b1)
	// comb arc S0 --> Z
	 (S0 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b0 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b0 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b0 && I1===1'b1 && I2===1'b1 && I3===1'b1 && S0===1'b0)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b0 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	if(I0===1'b1 && I1===1'b0 && I2===1'b1 && I3===1'b1 && S0===1'b1)
	// comb arc S1 --> Z
	 (S1 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd02d0( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd02d0_func nd02d0_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd02d0_func nd02d0_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd02d1( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd02d1_func nd02d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd02d1_func nd02d1_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd02d2( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd02d2_func nd02d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd02d2_func nd02d2_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd02d4( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd02d4_func nd02d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd02d4_func nd02d4_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd02d7( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd02d7_func nd02d7_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd02d7_func nd02d7_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd02da( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd02da_func nd02da_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd02da_func nd02da_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd03d0( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd03d0_func nd03d0_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd03d0_func nd03d0_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd03d1( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd03d1_func nd03d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd03d1_func nd03d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd03d2( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd03d2_func nd03d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd03d2_func nd03d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd03d4( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd03d4_func nd03d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd03d4_func nd03d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd03d7( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd03d7_func nd03d7_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd03d7_func nd03d7_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd03da( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd03da_func nd03da_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd03da_func nd03da_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd04d0( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd04d0_func nd04d0_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nd04d0_func nd04d0_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd04d1( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd04d1_func nd04d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nd04d1_func nd04d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd04d2( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd04d2_func nd04d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nd04d2_func nd04d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd04d4( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd04d4_func nd04d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nd04d4_func nd04d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd04d7( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd04d7_func nd04d7_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nd04d7_func nd04d7_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd04da( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd04da_func nd04da_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nd04da_func nd04da_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd12d0( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd12d0_func nd12d0_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd12d0_func nd12d0_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd12d1( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd12d1_func nd12d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd12d1_func nd12d1_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd12d2( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd12d2_func nd12d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd12d2_func nd12d2_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd12d4( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd12d4_func nd12d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nd12d4_func nd12d4_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd13d1( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd13d1_func nd13d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd13d1_func nd13d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd13d2( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd13d2_func nd13d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd13d2_func nd13d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd13d4( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd13d4_func nd13d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd13d4_func nd13d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd23d1( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd23d1_func nd23d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd23d1_func nd23d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd23d2( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd23d2_func nd23d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd23d2_func nd23d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nd23d4( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nd23d4_func nd23d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nd23d4_func nd23d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr02d0( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr02d0_func nr02d0_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nr02d0_func nr02d0_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr02d1( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr02d1_func nr02d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nr02d1_func nr02d1_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr02d2( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr02d2_func nr02d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nr02d2_func nr02d2_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr02d4( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr02d4_func nr02d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nr02d4_func nr02d4_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr02d7( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr02d7_func nr02d7_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nr02d7_func nr02d7_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr02da( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr02da_func nr02da_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	nr02da_func nr02da_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr03d0( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr03d0_func nr03d0_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr03d0_func nr03d0_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr03d1( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr03d1_func nr03d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr03d1_func nr03d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr03d2( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr03d2_func nr03d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr03d2_func nr03d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr03d4( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr03d4_func nr03d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr03d4_func nr03d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr03d7( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr03d7_func nr03d7_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr03d7_func nr03d7_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr03da( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr03da_func nr03da_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr03da_func nr03da_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr04d0( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr04d0_func nr04d0_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nr04d0_func nr04d0_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr04d1( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr04d1_func nr04d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nr04d1_func nr04d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr04d2( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr04d2_func nr04d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nr04d2_func nr04d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr04d4( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr04d4_func nr04d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nr04d4_func nr04d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr04d7( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr04d7_func nr04d7_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nr04d7_func nr04d7_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr04da( ZN, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr04da_func nr04da_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	nr04da_func nr04da_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// comb arc A4 --> ZN
	 (A4 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr13d1( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr13d1_func nr13d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr13d1_func nr13d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr13d2( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr13d2_func nr13d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr13d2_func nr13d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr13d4( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr13d4_func nr13d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr13d4_func nr13d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr23d1( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr23d1_func nr23d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr23d1_func nr23d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr23d2( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr23d2_func nr23d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr23d2_func nr23d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module nr23d4( ZN, A1, A2, A3 );
input A1, A2, A3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	nr23d4_func nr23d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));

   `else

	nr23d4_func nr23d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc A3 --> ZN
	 (A3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai211d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai211d1_func oai211d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oai211d1_func oai211d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai211d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai211d2_func oai211d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oai211d2_func oai211d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai211d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai211d4_func oai211d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oai211d4_func oai211d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai21d1( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai21d1_func oai21d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	oai21d1_func oai21d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai21d2( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai21d2_func oai21d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	oai21d2_func oai21d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai21d4( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai21d4_func oai21d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	oai21d4_func oai21d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai221d1( ZN, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai221d1_func oai221d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	oai221d1_func oai221d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai221d2( ZN, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai221d2_func oai221d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	oai221d2_func oai221d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai221d4( ZN, A, B1, B2, C1, C2 );
input A, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai221d4_func oai221d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	oai221d4_func oai221d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai2222d1( ZN, A1, A2, B1, B2, C1, C2, D1, D2 );
input A1, A2, B1, B2, C1, C2, D1, D2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai2222d1_func oai2222d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));

   `else

	oai2222d1_func oai2222d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc D1 --> ZN
	 (D1 => ZN) = (1.0,1.0);

	// comb arc D2 --> ZN
	 (D2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai2222d2( ZN, A1, A2, B1, B2, C1, C2, D1, D2 );
input A1, A2, B1, B2, C1, C2, D1, D2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai2222d2_func oai2222d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));

   `else

	oai2222d2_func oai2222d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc D1 --> ZN
	 (D1 => ZN) = (1.0,1.0);

	// comb arc D2 --> ZN
	 (D2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai2222d4( ZN, A1, A2, B1, B2, C1, C2, D1, D2 );
input A1, A2, B1, B2, C1, C2, D1, D2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai2222d4_func oai2222d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));

   `else

	oai2222d4_func oai2222d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.D1(D1),.D2(D2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc D1 --> ZN
	 (D1 => ZN) = (1.0,1.0);

	// comb arc D2 --> ZN
	 (D2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai222d1( ZN, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai222d1_func oai222d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	oai222d1_func oai222d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai222d2( ZN, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai222d2_func oai222d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	oai222d2_func oai222d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai222d4( ZN, A1, A2, B1, B2, C1, C2 );
input A1, A2, B1, B2, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai222d4_func oai222d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));

   `else

	oai222d4_func oai222d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai22d1( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai22d1_func oai22d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	oai22d1_func oai22d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai22d2( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai22d2_func oai22d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	oai22d2_func oai22d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai22d4( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai22d4_func oai22d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	oai22d4_func oai22d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai311d1( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai311d1_func oai311d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai311d1_func oai311d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai311d2( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai311d2_func oai311d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai311d2_func oai311d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai311d4( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai311d4_func oai311d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai311d4_func oai311d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai31d1( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai31d1_func oai31d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	oai31d1_func oai31d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai31d2( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai31d2_func oai31d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	oai31d2_func oai31d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai31d4( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai31d4_func oai31d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	oai31d4_func oai31d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai321d1( ZN, A, B1, B2, C1, C2, C3 );
input A, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai321d1_func oai321d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai321d1_func oai321d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai321d2( ZN, A, B1, B2, C1, C2, C3 );
input A, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai321d2_func oai321d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai321d2_func oai321d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai321d4( ZN, A, B1, B2, C1, C2, C3 );
input A, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai321d4_func oai321d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai321d4_func oai321d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai322d1( ZN, A1, A2, B1, B2, C1, C2, C3 );
input A1, A2, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai322d1_func oai322d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai322d1_func oai322d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai322d2( ZN, A1, A2, B1, B2, C1, C2, C3 );
input A1, A2, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai322d2_func oai322d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai322d2_func oai322d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oai322d4( ZN, A1, A2, B1, B2, C1, C2, C3 );
input A1, A2, B1, B2, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oai322d4_func oai322d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));

   `else

	oai322d4_func oai322d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim211d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim211d1_func oaim211d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oaim211d1_func oaim211d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim211d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim211d2_func oaim211d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oaim211d2_func oaim211d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim211d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim211d4_func oaim211d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oaim211d4_func oaim211d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim21d1( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim21d1_func oaim21d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	oaim21d1_func oaim21d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim21d2( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim21d2_func oaim21d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	oaim21d2_func oaim21d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim21d4( ZN, A, B1, B2 );
input A, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim21d4_func oaim21d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));

   `else

	oaim21d4_func oaim21d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim22d1( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim22d1_func oaim22d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	oaim22d1_func oaim22d1_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim22d2( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim22d2_func oaim22d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	oaim22d2_func oaim22d2_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim22d4( ZN, A1, A2, B1, B2 );
input A1, A2, B1, B2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim22d4_func oaim22d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));

   `else

	oaim22d4_func oaim22d4_inst(.ZN(ZN),.A1(A1),.A2(A2),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> ZN
	 (A1 => ZN) = (1.0,1.0);

	// comb arc A2 --> ZN
	 (A2 => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim2m11d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim2m11d1_func oaim2m11d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oaim2m11d1_func oaim2m11d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim2m11d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim2m11d2_func oaim2m11d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oaim2m11d2_func oaim2m11d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim2m11d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim2m11d4_func oaim2m11d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oaim2m11d4_func oaim2m11d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim311d1( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim311d1_func oaim311d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oaim311d1_func oaim311d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim311d2( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim311d2_func oaim311d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oaim311d2_func oaim311d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim311d4( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim311d4_func oaim311d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oaim311d4_func oaim311d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim31d1( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim31d1_func oaim31d1_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	oaim31d1_func oaim31d1_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim31d2( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim31d2_func oaim31d2_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	oaim31d2_func oaim31d2_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim31d4( ZN, A, B1, B2, B3 );
input A, B1, B2, B3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim31d4_func oaim31d4_behav_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	oaim31d4_func oaim31d4_inst(.ZN(ZN),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B1 --> ZN
	 (B1 => ZN) = (1.0,1.0);

	// comb arc B2 --> ZN
	 (B2 => ZN) = (1.0,1.0);

	// comb arc B3 --> ZN
	 (B3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim3m11d1( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim3m11d1_func oaim3m11d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oaim3m11d1_func oaim3m11d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim3m11d2( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim3m11d2_func oaim3m11d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oaim3m11d2_func oaim3m11d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oaim3m11d4( ZN, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oaim3m11d4_func oaim3m11d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	oaim3m11d4_func oaim3m11d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// comb arc C3 --> ZN
	 (C3 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oan211d1( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oan211d1_func oan211d1_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oan211d1_func oan211d1_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oan211d2( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oan211d2_func oan211d2_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oan211d2_func oan211d2_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module oan211d4( ZN, A, B, C1, C2 );
input A, B, C1, C2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	oan211d4_func oan211d4_behav_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	oan211d4_func oan211d4_inst(.ZN(ZN),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> ZN
	 (A => ZN) = (1.0,1.0);

	// comb arc B --> ZN
	 (B => ZN) = (1.0,1.0);

	// comb arc C1 --> ZN
	 (C1 => ZN) = (1.0,1.0);

	// comb arc C2 --> ZN
	 (C2 => ZN) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or02d0( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or02d0_func or02d0_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	or02d0_func or02d0_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or02d1( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or02d1_func or02d1_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	or02d1_func or02d1_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or02d2( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or02d2_func or02d2_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	or02d2_func or02d2_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or02d4( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or02d4_func or02d4_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	or02d4_func or02d4_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or02d7( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or02d7_func or02d7_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	or02d7_func or02d7_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or02da( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or02da_func or02da_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	or02da_func or02da_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or03d0( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or03d0_func or03d0_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	or03d0_func or03d0_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or03d1( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or03d1_func or03d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	or03d1_func or03d1_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or03d2( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or03d2_func or03d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	or03d2_func or03d2_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or03d4( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or03d4_func or03d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	or03d4_func or03d4_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or03d7( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or03d7_func or03d7_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	or03d7_func or03d7_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or03da( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or03da_func or03da_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	or03da_func or03da_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or04d0( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or04d0_func or04d0_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	or04d0_func or04d0_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or04d1( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or04d1_func or04d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	or04d1_func or04d1_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or04d2( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or04d2_func or04d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	or04d2_func or04d2_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or04d4( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or04d4_func or04d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	or04d4_func or04d4_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or04d7( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or04d7_func or04d7_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	or04d7_func or04d7_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module or04da( Z, A1, A2, A3, A4 );
input A1, A2, A3, A4;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	or04da_func or04da_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));

   `else

	or04da_func or04da_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3),.A4(A4));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// comb arc A4 --> Z
	 (A4 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora211d1( Z, A, B, C1, C2 );
input A, B, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora211d1_func ora211d1_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	ora211d1_func ora211d1_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora211d2( Z, A, B, C1, C2 );
input A, B, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora211d2_func ora211d2_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	ora211d2_func ora211d2_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora211d4( Z, A, B, C1, C2 );
input A, B, C1, C2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora211d4_func ora211d4_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));

   `else

	ora211d4_func ora211d4_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora21d1( Z, A, B1, B2 );
input A, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora21d1_func ora21d1_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));

   `else

	ora21d1_func ora21d1_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora21d2( Z, A, B1, B2 );
input A, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora21d2_func ora21d2_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));

   `else

	ora21d2_func ora21d2_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora21d4( Z, A, B1, B2 );
input A, B1, B2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora21d4_func ora21d4_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));

   `else

	ora21d4_func ora21d4_inst(.Z(Z),.A(A),.B1(B1),.B2(B2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora311d1( Z, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora311d1_func ora311d1_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	ora311d1_func ora311d1_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// comb arc C3 --> Z
	 (C3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora311d2( Z, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora311d2_func ora311d2_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	ora311d2_func ora311d2_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// comb arc C3 --> Z
	 (C3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora311d4( Z, A, B, C1, C2, C3 );
input A, B, C1, C2, C3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora311d4_func ora311d4_behav_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));

   `else

	ora311d4_func ora311d4_inst(.Z(Z),.A(A),.B(B),.C1(C1),.C2(C2),.C3(C3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B --> Z
	 (B => Z) = (1.0,1.0);

	// comb arc C1 --> Z
	 (C1 => Z) = (1.0,1.0);

	// comb arc C2 --> Z
	 (C2 => Z) = (1.0,1.0);

	// comb arc C3 --> Z
	 (C3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora31d1( Z, A, B1, B2, B3 );
input A, B1, B2, B3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora31d1_func ora31d1_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	ora31d1_func ora31d1_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc B3 --> Z
	 (B3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora31d2( Z, A, B1, B2, B3 );
input A, B1, B2, B3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora31d2_func ora31d2_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	ora31d2_func ora31d2_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc B3 --> Z
	 (B3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ora31d4( Z, A, B1, B2, B3 );
input A, B1, B2, B3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	ora31d4_func ora31d4_behav_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));

   `else

	ora31d4_func ora31d4_inst(.Z(Z),.A(A),.B1(B1),.B2(B2),.B3(B3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> Z
	 (A => Z) = (1.0,1.0);

	// comb arc B1 --> Z
	 (B1 => Z) = (1.0,1.0);

	// comb arc B2 --> Z
	 (B2 => Z) = (1.0,1.0);

	// comb arc B3 --> Z
	 (B3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdbfb1( Q, QN, CDN, CPN, D, SC, SD, SDN );
input CDN, CPN, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdbfb1_func sdbfb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdbfb1_func sdbfb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdbfb2( Q, QN, CDN, CPN, D, SC, SD, SDN );
input CDN, CPN, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdbfb2_func sdbfb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdbfb2_func sdbfb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdbfb4( Q, QN, CDN, CPN, D, SC, SD, SDN );
input CDN, CPN, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdbfb4_func sdbfb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdbfb4_func sdbfb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdbrb1( Q, QN, CDN, CP, D, SC, SD, SDN );
input CDN, CP, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdbrb1_func sdbrb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdbrb1_func sdbrb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdbrb2( Q, QN, CDN, CP, D, SC, SD, SDN );
input CDN, CP, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdbrb2_func sdbrb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdbrb2_func sdbrb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdbrb4( Q, QN, CDN, CP, D, SC, SD, SDN );
input CDN, CP, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdbrb4_func sdbrb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdbrb4_func sdbrb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcfb1( Q, QN, CDN, CPN, D, SC, SD );
input CDN, CPN, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcfb1_func sdcfb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcfb1_func sdcfb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcfb2( Q, QN, CDN, CPN, D, SC, SD );
input CDN, CPN, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcfb2_func sdcfb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcfb2_func sdcfb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcfb4( Q, QN, CDN, CPN, D, SC, SD );
input CDN, CPN, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcfb4_func sdcfb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcfb4_func sdcfb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcfq1( Q, CDN, CPN, D, SC, SD );
input CDN, CPN, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcfq1_func sdcfq1_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcfq1_func sdcfq1_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcfq2( Q, CDN, CPN, D, SC, SD );
input CDN, CPN, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcfq2_func sdcfq2_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcfq2_func sdcfq2_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcfq4( Q, CDN, CPN, D, SC, SD );
input CDN, CPN, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcfq4_func sdcfq4_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcfq4_func sdcfq4_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrb1( Q, QN, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrb1_func sdcrb1_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrb1_func sdcrb1_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrb2( Q, QN, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrb2_func sdcrb2_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrb2_func sdcrb2_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrb4( Q, QN, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrb4_func sdcrb4_behav_inst(.Q(Q),.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrb4_func sdcrb4_inst(.Q(Q),.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrn1( QN, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrn1_func sdcrn1_behav_inst(.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrn1_func sdcrn1_inst(.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrn2( QN, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrn2_func sdcrn2_behav_inst(.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrn2_func sdcrn2_inst(.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrn4( QN, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrn4_func sdcrn4_behav_inst(.QN(QN),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrn4_func sdcrn4_inst(.QN(QN),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrq1( Q, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrq1_func sdcrq1_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrq1_func sdcrq1_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrq2( Q, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrq2_func sdcrq2_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrq2_func sdcrq2_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdcrq4( Q, CDN, CP, D, SC, SD );
input CDN, CP, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdcrq4_func sdcrq4_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdcrq4_func sdcrq4_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnfb1( Q, QN, CPN, D, SC, SD );
input CPN, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnfb1_func sdnfb1_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnfb1_func sdnfb1_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnfb2( Q, QN, CPN, D, SC, SD );
input CPN, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnfb2_func sdnfb2_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnfb2_func sdnfb2_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnfb4( Q, QN, CPN, D, SC, SD );
input CPN, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnfb4_func sdnfb4_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnfb4_func sdnfb4_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrb1( Q, QN, CP, D, SC, SD );
input CP, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrb1_func sdnrb1_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrb1_func sdnrb1_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrb2( Q, QN, CP, D, SC, SD );
input CP, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrb2_func sdnrb2_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrb2_func sdnrb2_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrb4( Q, QN, CP, D, SC, SD );
input CP, D, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrb4_func sdnrb4_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrb4_func sdnrb4_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrn1( QN, CP, D, SC, SD );
input CP, D, SC, SD;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrn1_func sdnrn1_behav_inst(.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrn1_func sdnrn1_inst(.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrn2( QN, CP, D, SC, SD );
input CP, D, SC, SD;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrn2_func sdnrn2_behav_inst(.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrn2_func sdnrn2_inst(.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrn4( QN, CP, D, SC, SD );
input CP, D, SC, SD;
output QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrn4_func sdnrn4_behav_inst(.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrn4_func sdnrn4_inst(.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrq1( Q, CP, D, SC, SD );
input CP, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrq1_func sdnrq1_behav_inst(.Q(Q),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrq1_func sdnrq1_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrq2( Q, CP, D, SC, SD );
input CP, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrq2_func sdnrq2_behav_inst(.Q(Q),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrq2_func sdnrq2_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdnrq4( Q, CP, D, SC, SD );
input CP, D, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdnrq4_func sdnrq4_behav_inst(.Q(Q),.CP(CP),.D(D),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	sdnrq4_func sdnrq4_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdpfb1( Q, QN, CPN, D, SC, SD, SDN );
input CPN, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdpfb1_func sdpfb1_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdpfb1_func sdpfb1_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W0);


	and MGM_G2(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdpfb2( Q, QN, CPN, D, SC, SD, SDN );
input CPN, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdpfb2_func sdpfb2_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdpfb2_func sdpfb2_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W0);


	and MGM_G2(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdpfb4( Q, QN, CPN, D, SC, SD, SDN );
input CPN, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdpfb4_func sdpfb4_behav_inst(.Q(Q),.QN(QN),.CPN(CPN),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdpfb4_func sdpfb4_inst(.Q(Q),.QN(QN),.CPN(CPN_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W0);


	and MGM_G2(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> QN
	(negedge CPN => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdprb1( Q, QN, CP, D, SC, SD, SDN );
input CP, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdprb1_func sdprb1_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdprb1_func sdprb1_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W0);


	and MGM_G2(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdprb2( Q, QN, CP, D, SC, SD, SDN );
input CP, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdprb2_func sdprb2_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdprb2_func sdprb2_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W0);


	and MGM_G2(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sdprb4( Q, QN, CP, D, SC, SD, SDN );
input CP, D, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sdprb4_func sdprb4_behav_inst(.Q(Q),.QN(QN),.CP(CP),.D(D),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sdprb4_func sdprb4_inst(.Q(Q),.QN(QN),.CP(CP_delay),.D(D_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W0);


	and MGM_G2(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module secfq1( Q, CDN, CPN, D, ENN, SC, SD );
input CDN, CPN, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	secfq1_func secfq1_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	secfq1_func secfq1_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	not MGM_G2(MGM_W2,SC_delay);


	and MGM_G3(ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC,MGM_W2,MGM_W1);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_CDN_AND_NOT_SC,MGM_W3,CDN_delay);


	and MGM_G6(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module secfq2( Q, CDN, CPN, D, ENN, SC, SD );
input CDN, CPN, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	secfq2_func secfq2_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	secfq2_func secfq2_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	not MGM_G2(MGM_W2,SC_delay);


	and MGM_G3(ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC,MGM_W2,MGM_W1);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_CDN_AND_NOT_SC,MGM_W3,CDN_delay);


	and MGM_G6(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module secfq4( Q, CDN, CPN, D, ENN, SC, SD );
input CDN, CPN, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	secfq4_func secfq4_behav_inst(.Q(Q),.CDN(CDN),.CPN(CPN),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	secfq4_func secfq4_inst(.Q(Q),.CDN(CDN_delay),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	not MGM_G2(MGM_W2,SC_delay);


	and MGM_G3(ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC,MGM_W2,MGM_W1);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_CDN_AND_NOT_SC,MGM_W3,CDN_delay);


	and MGM_G6(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// recrem CDN-CPN-negedge
	$recrem(posedge CDN,negedge CPN,1.0,1.0,notifier,,,CDN_delay,CPN_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module secrq1( Q, CDN, CP, D, ENN, SC, SD );
input CDN, CP, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	secrq1_func secrq1_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	secrq1_func secrq1_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	not MGM_G2(MGM_W2,SC_delay);


	and MGM_G3(ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC,MGM_W2,MGM_W1);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_CDN_AND_NOT_SC,MGM_W3,CDN_delay);


	and MGM_G6(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module secrq2( Q, CDN, CP, D, ENN, SC, SD );
input CDN, CP, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	secrq2_func secrq2_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	secrq2_func secrq2_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	not MGM_G2(MGM_W2,SC_delay);


	and MGM_G3(ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC,MGM_W2,MGM_W1);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_CDN_AND_NOT_SC,MGM_W3,CDN_delay);


	and MGM_G6(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module secrq4( Q, CDN, CP, D, ENN, SC, SD );
input CDN, CP, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	secrq4_func secrq4_behav_inst(.Q(Q),.CDN(CDN),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	secrq4_func secrq4_inst(.Q(Q),.CDN(CDN_delay),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	not MGM_G2(MGM_W2,SC_delay);


	and MGM_G3(ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC,MGM_W2,MGM_W1);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_CDN_AND_NOT_SC,MGM_W3,CDN_delay);


	and MGM_G6(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module senrb1( Q, QN, D, SD, CP, ENN, SC );
input CP, D, ENN, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	senrb1_func senrb1_behav_inst(.Q(Q),.QN(QN),.D(D),.SD(SD),.CP(CP),.ENN(ENN),.SC(SC),.notifier(notifier));

   `else

	wire D_delay ;

	wire SD_delay ;

	wire CP_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	senrb1_func senrb1_inst(.Q(Q),.QN(QN),.D(D_delay),.SD(SD_delay),.CP(CP_delay),.ENN(ENN_delay),.SC(SC_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(ENABLE_NOT_ENN_AND_NOT_SC,MGM_W1,MGM_W0);


	not MGM_G3(ENABLE_NOT_SC,SC_delay);


	buf MGM_G4(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module senrb2( Q, QN, D, SD, CP, ENN, SC );
input CP, D, ENN, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	senrb2_func senrb2_behav_inst(.Q(Q),.QN(QN),.D(D),.SD(SD),.CP(CP),.ENN(ENN),.SC(SC),.notifier(notifier));

   `else

	wire D_delay ;

	wire SD_delay ;

	wire CP_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	senrb2_func senrb2_inst(.Q(Q),.QN(QN),.D(D_delay),.SD(SD_delay),.CP(CP_delay),.ENN(ENN_delay),.SC(SC_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(ENABLE_NOT_ENN_AND_NOT_SC,MGM_W1,MGM_W0);


	not MGM_G3(ENABLE_NOT_SC,SC_delay);


	buf MGM_G4(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module senrb4( Q, QN, D, SD, CP, ENN, SC );
input CP, D, ENN, SC, SD;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	senrb4_func senrb4_behav_inst(.Q(Q),.QN(QN),.D(D),.SD(SD),.CP(CP),.ENN(ENN),.SC(SC),.notifier(notifier));

   `else

	wire D_delay ;

	wire SD_delay ;

	wire CP_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	senrb4_func senrb4_inst(.Q(Q),.QN(QN),.D(D_delay),.SD(SD_delay),.CP(CP_delay),.ENN(ENN_delay),.SC(SC_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(ENABLE_NOT_ENN_AND_NOT_SC,MGM_W1,MGM_W0);


	not MGM_G3(ENABLE_NOT_SC,SC_delay);


	buf MGM_G4(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module senrq1( Q, CP, D, ENN, SC, SD );
input CP, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	senrq1_func senrq1_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	senrq1_func senrq1_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(ENABLE_NOT_ENN_AND_NOT_SC,MGM_W1,MGM_W0);


	not MGM_G3(ENABLE_NOT_SC,SC_delay);


	buf MGM_G4(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module senrq2( Q, CP, D, ENN, SC, SD );
input CP, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	senrq2_func senrq2_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	senrq2_func senrq2_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(ENABLE_NOT_ENN_AND_NOT_SC,MGM_W1,MGM_W0);


	not MGM_G3(ENABLE_NOT_SC,SC_delay);


	buf MGM_G4(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module senrq4( Q, CP, D, ENN, SC, SD );
input CP, D, ENN, SC, SD;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	senrq4_func senrq4_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	senrq4_func senrq4_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(ENABLE_NOT_ENN_AND_NOT_SC,MGM_W1,MGM_W0);


	not MGM_G3(ENABLE_NOT_SC,SC_delay);


	buf MGM_G4(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sepfq1( Q, CPN, D, ENN, SC, SD, SDN );
input CPN, D, ENN, SC, SD, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sepfq1_func sepfq1_behav_inst(.Q(Q),.CPN(CPN),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sepfq1_func sepfq1_inst(.Q(Q),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(MGM_W2,MGM_W1,MGM_W0);


	and MGM_G3(ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W2);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W3);


	and MGM_G6(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sepfq2( Q, CPN, D, ENN, SC, SD, SDN );
input CPN, D, ENN, SC, SD, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sepfq2_func sepfq2_behav_inst(.Q(Q),.CPN(CPN),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sepfq2_func sepfq2_inst(.Q(Q),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(MGM_W2,MGM_W1,MGM_W0);


	and MGM_G3(ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W2);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W3);


	and MGM_G6(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module sepfq4( Q, CPN, D, ENN, SC, SD, SDN );
input CPN, D, ENN, SC, SD, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	sepfq4_func sepfq4_behav_inst(.Q(Q),.CPN(CPN),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CPN_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	sepfq4_func sepfq4_inst(.Q(Q),.CPN(CPN_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(MGM_W2,MGM_W1,MGM_W0);


	and MGM_G3(ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W2);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W3);


	and MGM_G6(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CPN --> Q
	(negedge CPN => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold D- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,D_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold ENN- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,ENN_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,posedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SC- CPN-HL
	$setuphold(negedge CPN,negedge SC,1.0,1.0,notifier,,,CPN_delay,SC_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// setuphold SD- CPN-HL
	$setuphold(negedge CPN &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CPN_delay,SD_delay);

	// recrem SDN-CPN-negedge
	$recrem(posedge SDN,negedge CPN,1.0,1.0,notifier,,,SDN_delay,CPN_delay);

	// mpw CPN_lh 
	$width(posedge CPN,1.0,0,notifier);

	// mpw CPN_hl 
	$width(negedge CPN,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module seprq1( Q, CP, D, ENN, SC, SD, SDN );
input CP, D, ENN, SC, SD, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	seprq1_func seprq1_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	seprq1_func seprq1_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(MGM_W2,MGM_W1,MGM_W0);


	and MGM_G3(ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W2);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W3);


	and MGM_G6(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module seprq2( Q, CP, D, ENN, SC, SD, SDN );
input CP, D, ENN, SC, SD, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	seprq2_func seprq2_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	seprq2_func seprq2_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(MGM_W2,MGM_W1,MGM_W0);


	and MGM_G3(ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W2);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W3);


	and MGM_G6(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module seprq4( Q, CP, D, ENN, SC, SD, SDN );
input CP, D, ENN, SC, SD, SDN;
output Q;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	seprq4_func seprq4_behav_inst(.Q(Q),.CP(CP),.D(D),.ENN(ENN),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire D_delay ;

	wire ENN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	seprq4_func seprq4_inst(.Q(Q),.CP(CP_delay),.D(D_delay),.ENN(ENN_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,ENN_delay);


	not MGM_G1(MGM_W1,SC_delay);


	and MGM_G2(MGM_W2,MGM_W1,MGM_W0);


	and MGM_G3(ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W2);


	not MGM_G4(MGM_W3,SC_delay);


	and MGM_G5(ENABLE_NOT_SC_AND_SDN,SDN_delay,MGM_W3);


	and MGM_G6(ENABLE_SC_AND_SDN,SDN_delay,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CP --> Q
	(posedge CP => (Q : D))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold D- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_NOT_ENN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,D_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		posedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold ENN- CP-LH
	$setuphold(posedge CP &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		negedge ENN &&& (ENABLE_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,ENN_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module skbrb1( Q, QN, CP, CDN, J, KZ, SC, SD, SDN );
input CDN, CP, J, KZ, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	skbrb1_func skbrb1_behav_inst(.Q(Q),.QN(QN),.CP(CP),.CDN(CDN),.J(J),.KZ(KZ),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire CDN_delay ;

	wire J_delay ;

	wire KZ_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	skbrb1_func skbrb1_inst(.Q(Q),.QN(QN),.CP(CP_delay),.CDN(CDN_delay),.J(J_delay),.KZ(KZ_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : J))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : J))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge J &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge J &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge KZ &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge KZ &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module skbrb2( Q, QN, CP, CDN, J, KZ, SC, SD, SDN );
input CDN, CP, J, KZ, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	skbrb2_func skbrb2_behav_inst(.Q(Q),.QN(QN),.CP(CP),.CDN(CDN),.J(J),.KZ(KZ),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire CDN_delay ;

	wire J_delay ;

	wire KZ_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	skbrb2_func skbrb2_inst(.Q(Q),.QN(QN),.CP(CP_delay),.CDN(CDN_delay),.J(J_delay),.KZ(KZ_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : J))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : J))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge J &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge J &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge KZ &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge KZ &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module skbrb4( Q, QN, CP, CDN, J, KZ, SC, SD, SDN );
input CDN, CP, J, KZ, SC, SD, SDN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	skbrb4_func skbrb4_behav_inst(.Q(Q),.QN(QN),.CP(CP),.CDN(CDN),.J(J),.KZ(KZ),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CP_delay ;

	wire CDN_delay ;

	wire J_delay ;

	wire KZ_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	skbrb4_func skbrb4_inst(.Q(Q),.QN(QN),.CP(CP_delay),.CDN(CDN_delay),.J(J_delay),.KZ(KZ_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CP --> Q
	(posedge CP => (Q : J))  = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc CP --> QN
	(posedge CP => (QN : J))  = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// recrem CDN-CP-posedge
	$recrem(posedge CDN,posedge CP,1.0,1.0,notifier,,,CDN_delay,CP_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge J &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold J- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge J &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,J_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge KZ &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold KZ- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge KZ &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,KZ_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,posedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SC- CP-LH
	$setuphold(posedge CP,negedge SC,1.0,1.0,notifier,,,CP_delay,SC_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// setuphold SD- CP-LH
	$setuphold(posedge CP &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,CP_delay,SD_delay);

	// recrem SDN-CP-posedge
	$recrem(posedge SDN,posedge CP,1.0,1.0,notifier,,,SDN_delay,CP_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw CP_lh 
	$width(posedge CP,1.0,0,notifier);

	// mpw CP_hl 
	$width(negedge CP,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slbhb1( SO, Q, QN, CDN, D, E, SC, SD, SDN );
input CDN, D, E, SC, SD, SDN;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slbhb1_func slbhb1_behav_inst(.SO(SO),.Q(Q),.QN(QN),.CDN(CDN),.D(D),.E(E),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	slbhb1_func slbhb1_inst(.SO(SO),.Q(Q),.QN(QN),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// recrem CDN-E-posedge
	$recrem(negedge CDN,posedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// recrem SDN-E-negedge
	$recrem(posedge SDN,negedge E,1.0,1.0,notifier,,,SDN_delay,E_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slbhb2( SO, Q, QN, CDN, D, E, SC, SD, SDN );
input CDN, D, E, SC, SD, SDN;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slbhb2_func slbhb2_behav_inst(.SO(SO),.Q(Q),.QN(QN),.CDN(CDN),.D(D),.E(E),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	slbhb2_func slbhb2_inst(.SO(SO),.Q(Q),.QN(QN),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// recrem CDN-E-posedge
	$recrem(negedge CDN,posedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// recrem SDN-E-negedge
	$recrem(posedge SDN,negedge E,1.0,1.0,notifier,,,SDN_delay,E_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slbhb4( SO, Q, QN, CDN, D, E, SC, SD, SDN );
input CDN, D, E, SC, SD, SDN;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slbhb4_func slbhb4_behav_inst(.SO(SO),.Q(Q),.QN(QN),.CDN(CDN),.D(D),.E(E),.SC(SC),.SD(SD),.SDN(SDN),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	wire SDN_delay ;

	slbhb4_func slbhb4_inst(.SO(SO),.Q(Q),.QN(QN),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.SDN(SDN_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(MGM_W1,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_NOT_SC_AND_SDN,SDN_delay,MGM_W1);


	and MGM_G3(MGM_W2,SC_delay,CDN_delay);


	and MGM_G4(ENABLE_CDN_AND_SC_AND_SDN,SDN_delay,MGM_W2);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc SDN --> Q
	(negedge SDN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc CDN --> QN
	(negedge CDN => (QN+:1'b0))  = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc SDN --> QN
	(negedge SDN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// recrem CDN-E-posedge
	$recrem(negedge CDN,posedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC_AND_SDN === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// recrem SDN-E-negedge
	$recrem(posedge SDN,negedge E,1.0,1.0,notifier,,,SDN_delay,E_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// mpw SDN_hl 
	$width(negedge SDN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slchq1( SO, Q, CDN, D, E, SC, SD );
input CDN, D, E, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slchq1_func slchq1_behav_inst(.SO(SO),.Q(Q),.CDN(CDN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slchq1_func slchq1_inst(.SO(SO),.Q(Q),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// recrem CDN-E-posedge
	$recrem(negedge CDN,posedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slchq2( SO, Q, CDN, D, E, SC, SD );
input CDN, D, E, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slchq2_func slchq2_behav_inst(.SO(SO),.Q(Q),.CDN(CDN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slchq2_func slchq2_inst(.SO(SO),.Q(Q),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// recrem CDN-E-posedge
	$recrem(negedge CDN,posedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slchq4( SO, Q, CDN, D, E, SC, SD );
input CDN, D, E, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slchq4_func slchq4_behav_inst(.SO(SO),.Q(Q),.CDN(CDN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slchq4_func slchq4_inst(.SO(SO),.Q(Q),.CDN(CDN_delay),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// recrem CDN-E-negedge
	$recrem(posedge CDN,negedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// recrem CDN-E-posedge
	$recrem(negedge CDN,posedge E,1.0,1.0,notifier,,,CDN_delay,E_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slclq1( SO, Q, CDN, D, EN, SC, SD );
input CDN, D, EN, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slclq1_func slclq1_behav_inst(.SO(SO),.Q(Q),.CDN(CDN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slclq1_func slclq1_inst(.SO(SO),.Q(Q),.CDN(CDN_delay),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// recrem CDN-EN-posedge
	$recrem(posedge CDN,posedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// recrem CDN-EN-negedge
	$recrem(negedge CDN,negedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slclq2( SO, Q, CDN, D, EN, SC, SD );
input CDN, D, EN, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slclq2_func slclq2_behav_inst(.SO(SO),.Q(Q),.CDN(CDN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slclq2_func slclq2_inst(.SO(SO),.Q(Q),.CDN(CDN_delay),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// recrem CDN-EN-posedge
	$recrem(posedge CDN,posedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// recrem CDN-EN-negedge
	$recrem(negedge CDN,negedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slclq4( SO, Q, CDN, D, EN, SC, SD );
input CDN, D, EN, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slclq4_func slclq4_behav_inst(.SO(SO),.Q(Q),.CDN(CDN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire CDN_delay ;

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slclq4_func slclq4_inst(.SO(SO),.Q(Q),.CDN(CDN_delay),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(MGM_W0,SC_delay);


	and MGM_G1(ENABLE_CDN_AND_NOT_SC,MGM_W0,CDN_delay);


	and MGM_G2(ENABLE_CDN_AND_SC,SC_delay,CDN_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc CDN --> Q
	(negedge CDN => (Q+:1'b0))  = (1.0,1.0);

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// recrem CDN-EN-posedge
	$recrem(posedge CDN,posedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// recrem CDN-EN-negedge
	$recrem(negedge CDN,negedge EN,1.0,1.0,notifier,,,CDN_delay,EN_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_CDN_AND_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_SC === 1'b1),
		posedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_CDN_AND_SC === 1'b1),
		negedge SD &&& (ENABLE_CDN_AND_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw CDN_hl 
	$width(negedge CDN,1.0,0,notifier);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhb1( SO, Q, QN, D, E, SC, SD );
input D, E, SC, SD;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhb1_func slnhb1_behav_inst(.SO(SO),.Q(Q),.QN(QN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhb1_func slnhb1_inst(.SO(SO),.Q(Q),.QN(QN),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhb2( SO, Q, QN, D, E, SC, SD );
input D, E, SC, SD;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhb2_func slnhb2_behav_inst(.SO(SO),.Q(Q),.QN(QN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhb2_func slnhb2_inst(.SO(SO),.Q(Q),.QN(QN),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhb4( SO, Q, QN, D, E, SC, SD );
input D, E, SC, SD;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhb4_func slnhb4_behav_inst(.SO(SO),.Q(Q),.QN(QN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhb4_func slnhb4_inst(.SO(SO),.Q(Q),.QN(QN),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhn1( SO, QN, D, E, SC, SD );
input D, E, SC, SD;
output QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhn1_func slnhn1_behav_inst(.SO(SO),.QN(QN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhn1_func slnhn1_inst(.SO(SO),.QN(QN),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhn2( SO, QN, D, E, SC, SD );
input D, E, SC, SD;
output QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhn2_func slnhn2_behav_inst(.SO(SO),.QN(QN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhn2_func slnhn2_inst(.SO(SO),.QN(QN),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhn4( SO, QN, D, E, SC, SD );
input D, E, SC, SD;
output QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhn4_func slnhn4_behav_inst(.SO(SO),.QN(QN),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhn4_func slnhn4_inst(.SO(SO),.QN(QN),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc E --> QN
	(posedge E => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhq1( SO, Q, D, E, SC, SD );
input D, E, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhq1_func slnhq1_behav_inst(.SO(SO),.Q(Q),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhq1_func slnhq1_inst(.SO(SO),.Q(Q),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhq2( SO, Q, D, E, SC, SD );
input D, E, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhq2_func slnhq2_behav_inst(.SO(SO),.Q(Q),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhq2_func slnhq2_inst(.SO(SO),.Q(Q),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnhq4( SO, Q, D, E, SC, SD );
input D, E, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnhq4_func slnhq4_behav_inst(.SO(SO),.Q(Q),.D(D),.E(E),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnhq4_func slnhq4_inst(.SO(SO),.Q(Q),.D(D_delay),.E(E_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc E --> Q
	(posedge E => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnht1( SO, Z, D, E, OE, SC, SD );
input D, E, OE, SC, SD;
output SO, Z;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnht1_func slnht1_behav_inst(.SO(SO),.Z(Z),.D(D),.E(E),.OE(OE),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnht1_func slnht1_inst(.SO(SO),.Z(Z),.D(D_delay),.E(E_delay),.OE(OE),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// comb arc D --> Z
	 (D => Z) = (1.0,1.0);

	// seq arc E --> Z
	(posedge E => (Z : D))  = (1.0,1.0);

	// comb arc OE --> Z
	 (OE => Z) = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Z:SC)
	 (posedge SC => (Z:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Z:SC)
	 (negedge SC => (Z:SC)) = (1.0,1.0);

	// comb arc SD --> Z
	 (SD => Z) = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnht2( SO, Z, D, E, OE, SC, SD );
input D, E, OE, SC, SD;
output SO, Z;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnht2_func slnht2_behav_inst(.SO(SO),.Z(Z),.D(D),.E(E),.OE(OE),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnht2_func slnht2_inst(.SO(SO),.Z(Z),.D(D_delay),.E(E_delay),.OE(OE),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// comb arc D --> Z
	 (D => Z) = (1.0,1.0);

	// seq arc E --> Z
	(posedge E => (Z : D))  = (1.0,1.0);

	// comb arc OE --> Z
	 (OE => Z) = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Z:SC)
	 (posedge SC => (Z:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Z:SC)
	 (negedge SC => (Z:SC)) = (1.0,1.0);

	// comb arc SD --> Z
	 (SD => Z) = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnht4( SO, Z, D, E, OE, SC, SD );
input D, E, OE, SC, SD;
output SO, Z;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnht4_func slnht4_behav_inst(.SO(SO),.Z(Z),.D(D),.E(E),.OE(OE),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire E_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnht4_func slnht4_inst(.SO(SO),.Z(Z),.D(D_delay),.E(E_delay),.OE(OE),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc E --> SO
	(negedge E => (SO : D))  = (1.0,1.0);

	// comb arc D --> Z
	 (D => Z) = (1.0,1.0);

	// seq arc E --> Z
	(posedge E => (Z : D))  = (1.0,1.0);

	// comb arc OE --> Z
	 (OE => Z) = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Z:SC)
	 (posedge SC => (Z:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Z:SC)
	 (negedge SC => (Z:SC)) = (1.0,1.0);

	// comb arc SD --> Z
	 (SD => Z) = (1.0,1.0);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold D- E-HL
	$setuphold(negedge E &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,D_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,posedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SC- E-HL
	$setuphold(negedge E,negedge SC,1.0,1.0,notifier,,,E_delay,SC_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// setuphold SD- E-HL
	$setuphold(negedge E &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,E_delay,SD_delay);

	// mpw E_lh 
	$width(posedge E,1.0,0,notifier);

	// mpw E_hl 
	$width(negedge E,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnlb1( SO, Q, QN, D, EN, SC, SD );
input D, EN, SC, SD;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnlb1_func slnlb1_behav_inst(.SO(SO),.Q(Q),.QN(QN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnlb1_func slnlb1_inst(.SO(SO),.Q(Q),.QN(QN),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnlb2( SO, Q, QN, D, EN, SC, SD );
input D, EN, SC, SD;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnlb2_func slnlb2_behav_inst(.SO(SO),.Q(Q),.QN(QN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnlb2_func slnlb2_inst(.SO(SO),.Q(Q),.QN(QN),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnlb4( SO, Q, QN, D, EN, SC, SD );
input D, EN, SC, SD;
output Q, QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnlb4_func slnlb4_behav_inst(.SO(SO),.Q(Q),.QN(QN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnlb4_func slnlb4_inst(.SO(SO),.Q(Q),.QN(QN),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnln1( SO, QN, D, EN, SC, SD );
input D, EN, SC, SD;
output QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnln1_func slnln1_behav_inst(.SO(SO),.QN(QN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnln1_func slnln1_inst(.SO(SO),.QN(QN),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnln2( SO, QN, D, EN, SC, SD );
input D, EN, SC, SD;
output QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnln2_func slnln2_behav_inst(.SO(SO),.QN(QN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnln2_func slnln2_inst(.SO(SO),.QN(QN),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnln4( SO, QN, D, EN, SC, SD );
input D, EN, SC, SD;
output QN, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnln4_func slnln4_behav_inst(.SO(SO),.QN(QN),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnln4_func slnln4_inst(.SO(SO),.QN(QN),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> QN
	 (D => QN) = (1.0,1.0);

	// seq arc EN --> QN
	(negedge EN => (QN : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (QN:SC)
	 (posedge SC => (QN:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (QN:SC)
	 (negedge SC => (QN:SC)) = (1.0,1.0);

	// comb arc SD --> QN
	 (SD => QN) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnlq1( SO, Q, D, EN, SC, SD );
input D, EN, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnlq1_func slnlq1_behav_inst(.SO(SO),.Q(Q),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnlq1_func slnlq1_inst(.SO(SO),.Q(Q),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnlq2( SO, Q, D, EN, SC, SD );
input D, EN, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnlq2_func slnlq2_behav_inst(.SO(SO),.Q(Q),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnlq2_func slnlq2_inst(.SO(SO),.Q(Q),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module slnlq4( SO, Q, D, EN, SC, SD );
input D, EN, SC, SD;
output Q, SO;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	slnlq4_func slnlq4_behav_inst(.SO(SO),.Q(Q),.D(D),.EN(EN),.SC(SC),.SD(SD),.notifier(notifier));

   `else

	wire D_delay ;

	wire EN_delay ;

	wire SC_delay ;

	wire SD_delay ;

	slnlq4_func slnlq4_inst(.SO(SO),.Q(Q),.D(D_delay),.EN(EN_delay),.SC(SC_delay),.SD(SD_delay),.notifier(notifier));


	// spec_gates_begin


	not MGM_G0(ENABLE_NOT_SC,SC_delay);


	buf MGM_G1(ENABLE_SC,SC_delay);


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc D --> Q
	 (D => Q) = (1.0,1.0);

	// seq arc EN --> Q
	(negedge EN => (Q : D))  = (1.0,1.0);

	ifnone
	// comb arc posedge SC --> (Q:SC)
	 (posedge SC => (Q:SC)) = (1.0,1.0);

	ifnone
	// comb arc negedge SC --> (Q:SC)
	 (negedge SC => (Q:SC)) = (1.0,1.0);

	// comb arc SD --> Q
	 (SD => Q) = (1.0,1.0);

	// seq arc EN --> SO
	(posedge EN => (SO : D))  = (1.0,1.0);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		posedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold D- EN-LH
	$setuphold(posedge EN &&& (ENABLE_NOT_SC === 1'b1),
		negedge D &&& (ENABLE_NOT_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,D_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,posedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SC- EN-LH
	$setuphold(posedge EN,negedge SC,1.0,1.0,notifier,,,EN_delay,SC_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		posedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// setuphold SD- EN-LH
	$setuphold(posedge EN &&& (ENABLE_SC === 1'b1),
		negedge SD &&& (ENABLE_SC === 1'b1),
		1.0,1.0,notifier,,,EN_delay,SD_delay);

	// mpw EN_lh 
	$width(posedge EN,1.0,0,notifier);

	// mpw EN_hl 
	$width(negedge EN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module srlab1( Q, QN, RN, SN );
input RN, SN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	srlab1_func srlab1_behav_inst(.Q(Q),.QN(QN),.RN(RN),.SN(SN),.notifier(notifier));

   `else

	srlab1_func srlab1_inst(.Q(Q),.QN(QN),.RN(RN),.SN(SN),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc RN --> Q
	(negedge RN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc SN --> Q
	(negedge SN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc RN --> QN
	(negedge RN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc SN --> QN
	(negedge SN => (QN+:1'b0))  = (1.0,1.0);

	// mpw RN_hl 
	$width(negedge RN,1.0,0,notifier);

	// mpw SN_hl 
	$width(negedge SN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module srlab2( Q, QN, RN, SN );
input RN, SN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	srlab2_func srlab2_behav_inst(.Q(Q),.QN(QN),.RN(RN),.SN(SN),.notifier(notifier));

   `else

	srlab2_func srlab2_inst(.Q(Q),.QN(QN),.RN(RN),.SN(SN),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc RN --> Q
	(negedge RN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc SN --> Q
	(negedge SN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc RN --> QN
	(negedge RN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc SN --> QN
	(negedge SN => (QN+:1'b0))  = (1.0,1.0);

	// mpw RN_hl 
	$width(negedge RN,1.0,0,notifier);

	// mpw SN_hl 
	$width(negedge SN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module srlab4( Q, QN, RN, SN );
input RN, SN;
output Q, QN;
reg notifier;

   `ifdef FUNCTIONAL  //  functional //

	srlab4_func srlab4_behav_inst(.Q(Q),.QN(QN),.RN(RN),.SN(SN),.notifier(notifier));

   `else

	srlab4_func srlab4_inst(.Q(Q),.QN(QN),.RN(RN),.SN(SN),.notifier(notifier));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// seq arc RN --> Q
	(negedge RN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc SN --> Q
	(negedge SN => (Q+:1'b0))  = (1.0,1.0);

	// seq arc RN --> QN
	(negedge RN => (QN+:1'b0))  = (1.0,1.0);

	// seq arc SN --> QN
	(negedge SN => (QN+:1'b0))  = (1.0,1.0);

	// mpw RN_hl 
	$width(negedge RN,1.0,0,notifier);

	// mpw SN_hl 
	$width(negedge SN,1.0,0,notifier);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module su01d0( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	su01d0_func su01d0_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	su01d0_func su01d0_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module su01d1( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	su01d1_func su01d1_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	su01d1_func su01d1_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module su01d2( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	su01d2_func su01d2_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	su01d2_func su01d2_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module su01d4( CO, S, A, B, CI );
input A, B, CI;
output CO, S;

   `ifdef FUNCTIONAL  //  functional //

	su01d4_func su01d4_behav_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));

   `else

	su01d4_func su01d4_inst(.CO(CO),.S(S),.A(A),.B(B),.CI(CI));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// comb arc A --> CO
	 (A => CO) = (1.0,1.0);

	// comb arc B --> CO
	 (B => CO) = (1.0,1.0);

	// comb arc CI --> CO
	 (CI => CO) = (1.0,1.0);

	if(B===1'b0 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b0 && CI===1'b1)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(B===1'b1 && CI===1'b0)
	// comb arc A --> S
	 (A => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && CI===1'b1)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b1 && CI===1'b0)
	// comb arc B --> S
	 (B => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b0 && B===1'b1)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	if(A===1'b1 && B===1'b0)
	// comb arc CI --> S
	 (CI => S) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module tiehi( Z );
output Z;

   `ifdef FUNCTIONAL  //  functional //

	tiehi_func tiehi_behav_inst(.Z(Z));

   `else

	tiehi_func tiehi_inst(.Z(Z));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module tielo( Z );
output Z;

   `ifdef FUNCTIONAL  //  functional //

	tielo_func tielo_behav_inst(.Z(Z));

   `else

	tielo_func tielo_inst(.Z(Z));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xn02d1( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	xn02d1_func xn02d1_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	xn02d1_func xn02d1_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (ZN:A1)
	 (posedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (ZN:A1)
	 (negedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (ZN:A2)
	 (posedge A2 => (ZN:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (ZN:A2)
	 (negedge A2 => (ZN:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xn02d2( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	xn02d2_func xn02d2_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	xn02d2_func xn02d2_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (ZN:A1)
	 (posedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (ZN:A1)
	 (negedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (ZN:A2)
	 (posedge A2 => (ZN:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (ZN:A2)
	 (negedge A2 => (ZN:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xn02d4( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	xn02d4_func xn02d4_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	xn02d4_func xn02d4_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (ZN:A1)
	 (posedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (ZN:A1)
	 (negedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (ZN:A2)
	 (posedge A2 => (ZN:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (ZN:A2)
	 (negedge A2 => (ZN:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xn02d7( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	xn02d7_func xn02d7_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	xn02d7_func xn02d7_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (ZN:A1)
	 (posedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (ZN:A1)
	 (negedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (ZN:A2)
	 (posedge A2 => (ZN:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (ZN:A2)
	 (negedge A2 => (ZN:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xn02da( ZN, A1, A2 );
input A1, A2;
output ZN;

   `ifdef FUNCTIONAL  //  functional //

	xn02da_func xn02da_behav_inst(.ZN(ZN),.A1(A1),.A2(A2));

   `else

	xn02da_func xn02da_inst(.ZN(ZN),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (ZN:A1)
	 (posedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (ZN:A1)
	 (negedge A1 => (ZN:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (ZN:A2)
	 (posedge A2 => (ZN:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (ZN:A2)
	 (negedge A2 => (ZN:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr02d1( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr02d1_func xr02d1_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	xr02d1_func xr02d1_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (Z:A1)
	 (posedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (Z:A1)
	 (negedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (Z:A2)
	 (posedge A2 => (Z:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (Z:A2)
	 (negedge A2 => (Z:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr02d2( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr02d2_func xr02d2_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	xr02d2_func xr02d2_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (Z:A1)
	 (posedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (Z:A1)
	 (negedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (Z:A2)
	 (posedge A2 => (Z:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (Z:A2)
	 (negedge A2 => (Z:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr02d4( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr02d4_func xr02d4_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	xr02d4_func xr02d4_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (Z:A1)
	 (posedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (Z:A1)
	 (negedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (Z:A2)
	 (posedge A2 => (Z:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (Z:A2)
	 (negedge A2 => (Z:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr02d7( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr02d7_func xr02d7_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	xr02d7_func xr02d7_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (Z:A1)
	 (posedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (Z:A1)
	 (negedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (Z:A2)
	 (posedge A2 => (Z:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (Z:A2)
	 (negedge A2 => (Z:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr02da( Z, A1, A2 );
input A1, A2;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr02da_func xr02da_behav_inst(.Z(Z),.A1(A1),.A2(A2));

   `else

	xr02da_func xr02da_inst(.Z(Z),.A1(A1),.A2(A2));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	ifnone
	// comb arc posedge A1 --> (Z:A1)
	 (posedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc negedge A1 --> (Z:A1)
	 (negedge A1 => (Z:A1)) = (1.0,1.0);

	ifnone
	// comb arc posedge A2 --> (Z:A2)
	 (posedge A2 => (Z:A2)) = (1.0,1.0);

	ifnone
	// comb arc negedge A2 --> (Z:A2)
	 (negedge A2 => (Z:A2)) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr03d1( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr03d1_func xr03d1_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	xr03d1_func xr03d1_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	if(A2===1'b0 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b0 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr03d2( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr03d2_func xr03d2_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	xr03d2_func xr03d2_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	if(A2===1'b0 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b0 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr03d4( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr03d4_func xr03d4_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	xr03d4_func xr03d4_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	if(A2===1'b0 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b0 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr03d7( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr03d7_func xr03d7_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	xr03d7_func xr03d7_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	if(A2===1'b0 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b0 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module xr03da( Z, A1, A2, A3 );
input A1, A2, A3;
output Z;

   `ifdef FUNCTIONAL  //  functional //

	xr03da_func xr03da_behav_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));

   `else

	xr03da_func xr03da_inst(.Z(Z),.A1(A1),.A2(A2),.A3(A3));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	if(A2===1'b0 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b0 && A3===1'b0)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A2===1'b1 && A3===1'b1)
	// comb arc A1 --> Z
	 (A1 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A3===1'b0)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b1 && A3===1'b1)
	// comb arc A2 --> Z
	 (A2 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b0 && A2===1'b0)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	if(A1===1'b1 && A2===1'b1)
	// comb arc A3 --> Z
	 (A3 => Z) = (1.0,1.0);

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module ndiode( I );
input I;

   `ifdef FUNCTIONAL  //  functional //

	ndiode_func ndiode_behav_inst(.I(I));

   `else

	ndiode_func ndiode_inst(.I(I));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module tiehi1( Z );
output Z;

   `ifdef FUNCTIONAL  //  functional //

	tiehi1_func tiehi1_behav_inst(.Z(Z));

   `else

	tiehi1_func tiehi1_inst(.Z(Z));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine


`celldefine
module tielo1( Z );
output Z;

   `ifdef FUNCTIONAL  //  functional //

	tielo1_func tielo1_behav_inst(.Z(Z));

   `else

	tielo1_func tielo1_inst(.Z(Z));


	// spec_gates_begin


	// spec_gates_end



   specify

	// specify_block_begin 

	// specify_block_end 

   endspecify

   `endif 

endmodule
`endcelldefine
